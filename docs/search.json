[{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"case-study-with-miasim-strongly-interacting-species-sis-explaining-community-types","dir":"Articles > TreeSummarizedExperiment","previous_headings":"","what":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","title":"caseStudy1-SIS-TreeSE","text":"document provides detailed code required replicate case study 1 discussed Gao et al. (2023). Methods Ecology Evolution. DOI: 10.1111/2041-210X.14129 general instructions examples using miaSim package tools, see vignette. miaSim implements tools microbiome data simulation based different ecological modeling assumptions. can used simulate species abundance matrices, including time series. detailed function documentation, see function reference page Reference: Origins Control Community Types Human Microbiome aim case study recalculate Figure 2 demonstrates occurrence SIS clustering results communities. figure, left right, different power-law distributions (defined alpha = 7, 3, 2, 1.6, 1.01) controls strength frequency inter-species interactions. second row, inter-species interactions visualized networks. third row, different clustering results PCoA demonstrated. case study, used sets parameters, acquired similar results.","code":""},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"load-dependencies","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"Load dependencies","title":"caseStudy1-SIS-TreeSE","text":"","code":"library(ggplot2) # library(igraph) library(colourvalues) library(GGally) library(network) library(sna) library(ape) library(dplyr) library(philentropy) library(cluster) library(miaSim)"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"define-a-function-to-generate-power-law-distribution","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"Define a function to generate power-law distribution","title":"caseStudy1-SIS-TreeSE","text":"","code":"# FIXME: probably R already has some function for this; use that to simplify the code and # avoid unnecessary duplication rpower <- function(n, alpha, norm = FALSE) {   u <- runif(n, min = 0, max = 1 - .Machine$double.eps^0.5)   power <- (1 - u)^(1 / (1 - alpha))   if (norm) {     return(power / mean(power))   } else {     return(power)   } }"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"load-parameters-used-by-gibson-et-al-","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"Load parameters used by Gibson et al.","title":"caseStudy1-SIS-TreeSE","text":"","code":"params <- data.frame(   alpha = c(7, 3, 2, 1.6, 1.01),   t_end = c(20, 10, 5, 2, 1),   t_step = c(0.02, 0.01, 0.005, 0.002, 0.001) ) set.seed(42) n_species <- 100  # Define local communities; # we use here a smaller number in order to speed up demo calculations # local_communities <- seq_len(100) # Too slow!     local_communities <- c(1, 5, 10, 20) # Faster"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"create-variables-to-store-results","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"create variables to store results","title":"caseStudy1-SIS-TreeSE","text":"","code":"H <- list() df <- list() plot_hist <- list() N <- list() interactions_custom <- list() A <- list() g <- list() g_plot <- list() local_species_pool <- list() local_A <- list()"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"generate-constants-and-plot-different-distributions","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"generate constants and plot different distributions","title":"caseStudy1-SIS-TreeSE","text":"","code":"set.seed(42) for (row in seq_len(nrow(params))) {   # for each power-law distribution   print(paste(\"row =\", row))    H[[row]] <- rpower(n = n_species, alpha = params$alpha[row], norm = TRUE)   df[[row]] <- data.frame(H[[row]])   plot_hist[[row]] <- ggplot(df[[row]], aes(H[[row]])) +     ggtitle(paste(\"alpha =\", params$alpha[[row]])) +     geom_histogram(fill = \"steelblue\", color = \"grey20\", bins = 10) +     scale_y_log10(breaks = c(1, 10, 100), limits = c(1, 100)) +     theme_bw() +      theme(plot.title = element_text(hjust = 0.5))      # plot_hist[[row]]   print(plot_hist[[row]])    N[[row]] <- matrix(rnorm(n = n_species^2, mean = 0, sd = 1), nrow = n_species)   diag(N[[row]]) <- 0   interactions_custom[[row]] <- N[[row]] %*% diag(H[[row]])   A[[row]] <- randomA(     n_species = 100,     diagonal = -1,     scale_off_diagonal = 0.07,     connectance = 1,     interactions = interactions_custom[[row]]   )   g[[row]] <- graph_from_adjacency_matrix(A[[row]], weighted = TRUE, diag = FALSE)   print(paste(\"max edge weight =\", max(E(g[[row]])$weight)))   E(g[[row]])$color <- head(colour_values(c(abs(E(g[[row]])$weight), 0), alpha = 0, include_alpha = TRUE), -1)    g_plot[[row]] <- ggnet2(     net = g[[row]],     mode = \"circle\",     node.color = \"black\",     node.size = 1,     edge.color = \"color\", edge.alpha = 0.25   ) +      labs(title=paste(\"alpha =\", params$alpha[[row]])) +      theme(plot.title = element_text(hjust = 0.5))    print(g_plot[[row]])    local_species_pool[[row]] <- list()   local_A[[row]] <- list()    for (local_community in local_communities) {     local_species_pool[[row]][[local_community]] <- sample(x = 100, size = 80)     local_A[[row]][[local_community]] <- A[[row]][local_species_pool[[row]][[local_community]], local_species_pool[[row]][[local_community]]]   } }"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"identify-sis-using-hrow","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"identify SIS using H[[row]]","title":"caseStudy1-SIS-TreeSE","text":"","code":"SIS <- list() group_sis <- list() for (row in seq_len(nrow(params))) {   SIS[[row]] <- head(order(H[[row]], decreasing = TRUE), 1)   group_sis[[row]] <- list()   for (local_community in local_communities) {     if (paste0(\"sp\", SIS[[row]]) %in% rownames(local_A[[row]][[local_community]])) {       group_sis[[row]][[local_community]] <- \"with SIS\"     } else {       group_sis[[row]][[local_community]] <- \"without SIS\"     }   }   group_sis[[row]] <- unlist(group_sis[[row]]) }"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"simulate-glv-models-using-different-growth-rates-in-4-scenarios","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"simulate GLV models using different growth rates in 4 scenarios","title":"caseStudy1-SIS-TreeSE","text":"first scenario original one Gibson et al., rest explorations (second scenario assigning various growth rates random species; third scenario assigning faster growth rate SIS; fourth scenario assigning faster growth rate non-SIS). Different scenarios implemented overwriting default random growth rates simulation function.","code":""},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"prepare-result-lists-and-scenarios","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"prepare result lists and scenarios","title":"caseStudy1-SIS-TreeSE","text":"case study, focus first scenario. example uses smaller number local communities faster computations code can easily adapted vary numbers. order run several scenarios, can replace scenario <- 1 loop like (scenario seq_along(scenarios)) {...}.","code":"simulation_GLV <- list() otu_table <- list() jsd <- list() PCoA <- list() PCoA_coord <- list() bestk <- list() PAM <- list() SI <- list() groups <- list() pcoa_plot <- list() dfs_to_bind <- list()  scenarios <- c(\"original\", \"various growth rates\", \"SIS grows faster\", \"non-SIS grows faster\") growthRates <- vector(mode = \"list\", length = 4) growthRates[[1]] <- rep(1, 80) growthRates[[2]] <- NULL # growthRates for scenario 3 and 4 are assigned in the following loop customPalette <- c(\"#d95319\", \"#0072bd\", \"#edb120\", \"#7e2f8e\") scenario <- 1   print(paste0(\"scenario: \", scenarios[scenario]))    ### make new lists ####   simulation_GLV[[scenario]] <- list()   otu_table[[scenario]] <- list()   jsd[[scenario]] <- list()   PCoA[[scenario]] <- list()   PCoA_coord[[scenario]] <- list()   bestk[[scenario]] <- list()   PAM[[scenario]] <- list()   SI[[scenario]] <- list()   groups[[scenario]] <- list()   pcoa_plot[[scenario]] <- list()    ### run simulations ####   for (row in seq_len(nrow(params))) {     simulation_GLV[[scenario]][[row]] <- list()     otu_table[[scenario]][[row]] <- data.frame(matrix(nrow = 0, ncol = 100))     colnames(otu_table[[scenario]][[row]]) <- paste0(\"sp\", 1:100)     dfs_to_bind[[scenario]] <- list()      #### overwrite growth rates ####         # for (local_community in local_communities) {      for (local_community in local_communities) {          if (scenario == 3) {         growthRates[[scenario]] <- 9.9 * local_species_pool[[row]][[local_community]] == SIS[[row]] + 0.1       }       if (scenario == 4) {         growthRates[[scenario]] <- -9.9 * local_species_pool[[row]][[local_community]] == SIS[[row]] + 10       }        simulation_GLV[[scenario]][[row]][[local_community]] <- simulateGLV(         n_species = 80,         names_species = paste0(\"sp\", local_species_pool[[row]][[local_community]]),         A = local_A[[row]][[local_community]],         x0 = rep(1, 80),         growth_rates = growthRates[[scenario]],         t_end = params$t_end[row],         t_step = params$t_step[row],         stochastic = FALSE,         norm = TRUE       )        # makePlot(simulation_GLV[[scenario]][[row]][[local_community]]$matrix)       dfs_to_bind[[scenario]] <- append(dfs_to_bind[[scenario]], list(simulation_GLV[[scenario]][[row]][[local_community]]$matrix[time = 1000, ]))     }      ### form otu tables ####     otu_table[[scenario]][[row]] <- bind_rows(dfs_to_bind[[scenario]])     otu_table[[scenario]][[row]] <- subset(otu_table[[scenario]][[row]], select = -time)     otu_table[[scenario]][[row]][is.na(otu_table[[scenario]][[row]])] <- 0      ### calculate jensen-shannon distance and plot PCoA ####     jsd[[scenario]][[row]] <- JSD(as.matrix(otu_table[[scenario]][[row]]))     PCoA[[scenario]][[row]] <- ape::pcoa(as.dist(jsd[[scenario]][[row]]))     PCoA_coord[[scenario]][[row]] <- PCoA[[scenario]][[row]]$vectors[, 1:2]     colnames(PCoA_coord[[scenario]][[row]]) <- c(\"PCo1\", \"PCo2\")      bestk[[scenario]][[row]] <- 2     PAM[[scenario]][[row]] <- pam(PCoA[[scenario]][[row]]$vectors, k = 2)     SI[[scenario]][[row]] <- PAM[[scenario]][[row]]$silinfo$avg.width      # Too slow, let us limit k to 2..3 in the example (earlier 3:10)     for (k in 2:3) {       PAMtemp <- pam(PCoA[[scenario]][[row]]$vectors, k = k)       if (PAMtemp$silinfo$avg.width > SI[[scenario]][[row]]) {         SI[[scenario]][[row]] <- PAMtemp$silinfo$avg.width         bestk[[scenario]][[row]] <- k         PAM[[scenario]][[row]] <- PAMtemp       }     }      groups[[scenario]][[row]] <- factor(PAM[[scenario]][[row]]$clustering)      dataframe_pcoa <- as.data.frame(PCoA_coord[[scenario]][[row]])     dataframe_pcoa$group <- groups[[scenario]][[row]]     p <- ggplot(       dataframe_pcoa,       aes(x = PCo1, y = PCo2, color = group)     ) +       labs(title = paste(\"scenario\", scenario, scenarios[scenario], \";\", \"alpha =\", params$alpha[[row]])) +       geom_point() +       theme_bw() +       scale_color_manual(values = customPalette) +       theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5))            # Store the plot     pcoa_plot[[scenario]][[row]] <- p     # Show the plot     print(pcoa_plot[[scenario]][[row]])   }"},{"path":"/articles/TreeSummarizedExperiment/caseStudy1-SIS.html","id":"validate-relationship-between-cluster-and-sis","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Strongly interacting species (SIS) explaining community types","what":"validate relationship between cluster and SIS","title":"caseStudy1-SIS-TreeSE","text":"compare previou PCoA results PCoA results rendered /without SIS, can find last figures (alpha = 1.6 alpha=1.01, ’s one SIS), community types clustered way rendered /without SIS, indicating occurrence SIS can influence community types.","code":"pcoa_plot_sis <- list() for (row in seq_len(nrow(params))) {   pcoa_plot_sis[[row]] <- ggplot(as.data.frame(PCoA_coord[[1]][[row]]), aes(x = PCo1, y = PCo2)) +     geom_point(aes(colour = group_sis[[row]])) +     labs(title=paste(\"alpha =\", params$alpha[[row]])) +     theme_bw() +      theme(plot.title = element_text(hjust = 0.5))   print(pcoa_plot_sis[[row]]) # pcoa_validation_ plots }"},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"case-study-with-miasim-nutrient-concentration-threshold","dir":"Articles > TreeSummarizedExperiment","previous_headings":"","what":"Case study with miaSim: Nutrient concentration threshold","title":"caseStudy2-NutrientThreshold-TreeSE","text":"document provides detailed code required replicate case study 2 discussed Gao et al. (2023). Methods Ecology Evolution. DOI: 10.1111/2041-210X.14129 general instructions examples using miaSim package tools, see vignette. miaSim implements tools microbiome data simulation based different ecological modeling assumptions. can used simulate species abundance matrices, including time series. detailed function documentation, see function reference page Reference: Available energy fluxes drive transition diversity, stability, functional structure microbial communities. aim case study design demonstrate existence nutrient concentration threshold limits beta-diversity communities. fulfill aim, designed gradient environments, well gradient communities.","code":""},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"load-dependencies","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Nutrient concentration threshold","what":"Load dependencies","title":"caseStudy2-NutrientThreshold-TreeSE","text":"batch simulations time-consuming. reduce calculation burden, decreased numbers environments, resources, communities original 10 5, made minor modifications.","code":"library(ggplot2) library(vegan) library(reshape2) library(mia) library(miaSim) library(philentropy) library(cluster)  # Load auxiliary functions from: # https://github.com/microbiome/miaSim/blob/main/vignettes/funcs.R source(\"funcs.R\")"},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"set-random-seed-and-initial-shared-parameters","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Nutrient concentration threshold","what":"Set random seed and initial shared parameters","title":"caseStudy2-NutrientThreshold-TreeSE","text":"","code":"set.seed(42) n_species <- 5 n_resources <- 5 E <- randomE(n_species, n_resources, mean_consumption = 1, mean_production = 3) growth_rates <- runif(n_species) monod_constant <- matrix(rbeta(n_species*n_resources, 10,10),                                nrow=n_species,                    ncol=n_resources) t_store <- 50 n.instances <- 1 # no stochastic process: no need to repeat"},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"initialization","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Nutrient concentration threshold","what":"Initialization","title":"caseStudy2-NutrientThreshold-TreeSE","text":"Generate communities.  Initialize shared parameters. Generate resource gradients.","code":"n.community <- 5 # you can also try 20 or even 50. density.community <- 0.8 set.seed(42) # Check the Rmd source file for gradient.df.generator function source code: # https://github.com/microbiome/miaSim/blob/main/vignettes/caseStudy2-NutrientThreshold.Rmd community.initial.df <- gradient.df.generator(n_row = n.community,                                               n_col = n_species,                                               density_row = density.community,                           max_gradient = 0.7,                           error_interval = 0.1) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 dist.community.initial.df <- vegdist(community.initial.df, method = \"bray\")  # Create TreeSummarizedExperiment object for the initial community community.initial.tse <- TreeSummarizedExperiment(assays=SimpleList(abundances=t(as.matrix(community.initial.df))))  # Visualze dissimilarities for the initial community makeHeatmap(as.matrix(dist.community.initial.df),             title = \"dissimilarity matrix\",             x.label = \"community.1\",             y.label = \"community.2\") crm_params <- list(     n_species = n_species,     n_resources = n_resources,     x0 = NULL,     E = E,     resources = rep(1,n_resources),     monod_constant = monod_constant,     migration_p = 0,     stochastic = FALSE,     t_start = 0,     t_end = 50,     t_step = 1,     t_store = t_store,     growth_rates = growth_rates,     norm=FALSE) resourceConcentration <- 10^seq(0,4,1) # 1 to 10000 n.medium <- 5 density.medium <- 0.8 n_species <- 5 set.seed(42)  resource.initial.df <- gradient.df.generator(n_row = n.medium,     n_col = n_resources, density_row = density.medium,     max_gradient = 0.7, error_interval = 0.1) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5"},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"simulations","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Nutrient concentration threshold","what":"Simulations","title":"caseStudy2-NutrientThreshold-TreeSE","text":"","code":"# Pick the initial community initial.community <- assay(community.initial.tse, \"abundances\")  crmExample <- simulateConsumerResource(     n_species = n_species,     n_resources = n_resources,     E = E,     x0 = as.numeric(initial.community[,1]), # First sample from the initial community     resources = as.numeric(resourceConcentration[3]*resource.initial.df[1,]),     growth_rates = growth_rates,     monod_constant = monod_constant,     stochastic = FALSE,     t_end = 50,     t_step = 1,     t_store = 50,     norm = FALSE)  #makePlot(crmExample$matrix) tsem <- meltAssay(crmExample, assay.type = \"counts\", add_col_data = \"time\") p <- ggplot(tsem, aes(x=time, y=counts, color = FeatureID)) +         geom_line(show.legend = TRUE, lwd=0.5) +         labs(title=\"Species abundances by time\") +         theme_linedraw() +         theme(plot.title = element_text(hjust = 0.5, size = 14)) print(p) #makePlotRes(crmExample$resources) df <- as.data.frame(metadata(crmExample)$resources) df$time <- colData(crmExample)$time dft <-  melt(df, id=\"time\") names(dft) <- c(\"time\", \"resources\", \"S.t\") p <- ggplot(dft, aes(x=time, y=S.t, col = resources)) +         geom_line(show.legend = TRUE, lwd=0.5) +         labs(title=\"Quantity of compounds by time\") +         theme_linedraw() +         theme(plot.title = element_text(hjust = 0.5, size = 14)) # Generate simulations and store the final community in community.simulation # Here the final relative abundance table is basisComposition_prop.  set.seed(42) resourceConcentration <- 10^seq(0,4,1) # 1 to 10000 n.medium <- 5  # make use of parallel computing provided by package `foreach` library(foreach) library(doParallel) cl <- makeCluster(max(detectCores()/2, 1)) registerDoParallel(cl) basisComposition <- foreach(resConc = resourceConcentration, .combine = rbind) %:%      foreach(medium = seq_len(n.medium), .combine = rbind, .packages = \"miaSim\") %dopar% {         crm_params$resources <- as.numeric(resource.initial.df[medium,]*resConc)         paramx0 <- as.list(as.data.frame(t(community.initial.df)))         crm_param_iter <- list(x0 = paramx0)         print(paste(\"resConc\", resConc, \"medium\", medium))         crmMoments <- miaSim::generateSimulations(model = \"simulateConsumerResource\",                                            params_list = crm_params,                                            param_iter = crm_param_iter,                                            n_instances = n.instances,                                            t_end = 50)         # pick community composition at the last time point                as.data.frame(do.call(rbind, lapply(crmMoments, function (x) {assay(x, \"counts\")[, ncol(x)]})))     } stopCluster(cl) basisComposition_prop <- basisComposition / rowSums(basisComposition)"},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"make-umap-plots","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Nutrient concentration threshold","what":"Make UMAP plots","title":"caseStudy2-NutrientThreshold-TreeSE","text":"step, plot result stored umap_CRM_gradient_plot, visualized different facets.","code":"resourceConcentration <- 10^seq(0,4,1) # 1 to 10000 n.medium <- 5 n.community <- 5 concentration <- as.factor(rep(resourceConcentration, each = n.medium*n.community)) medium <- as.factor(rep(seq_len(n.medium), each = n.community ,times = length(resourceConcentration) )) community <- as.factor(rep(seq_len(n.community), times = length(resourceConcentration)*n.medium))  # Visualize with UMAP   ## Provide the community data as TreeSE object library(scater) tse <- TreeSummarizedExperiment(                 assays=SimpleList(abundances=t(as.matrix(basisComposition))),         colData=DataFrame(Medium=medium,                               Concentration=concentration,                       Community=community                       )             ) ## Add UMAP tse <- runUMAP(tse, name = \"UMAP\", exprs_values = \"abundances\")  ## Plot UMAP plotReducedDim(tse, \"UMAP\", colour_by=\"Medium\", shape_by=\"Concentration\")  # Same for compositional abundance data library(mia) ## add relative abundances; tse <- transformSamples(tse, assay.type=\"abundances\", method=\"relabundance\") tse <- runUMAP(tse, name = \"UMAP_compositional\", exprs_values = \"relabundance\") plotReducedDim(tse, \"UMAP_compositional\", colour_by=\"Medium\", shape_by=\"Concentration\") # Finally with communities umap_CRM_gradient_plot <<- plotReducedDim(tse, \"UMAP_compositional\",    colour_by=\"Medium\", shape_by=\"Community\", size_by=\"Concentration\")"},{"path":"/articles/TreeSummarizedExperiment/caseStudy2-NutrientThreshold.html","id":"visualization-of-the-results","dir":"Articles > TreeSummarizedExperiment","previous_headings":"Case study with miaSim: Nutrient concentration threshold","what":"Visualization of the results","title":"caseStudy2-NutrientThreshold-TreeSE","text":"part, different visualization results demonstrate (various facets) gradual change communities’ beta diversity. first figure indicates initial community composition important combinations initial available resources. first sub-figure second figure demonstrates oligotrophic (less available nutrients) environment, communities won’t change much given time, whilst last two sub-figures resemble , implying nutrient longer limiting factor beta-diversity community. pattern displayed following “curve plot”. third figure, second th community always stays similar, despite initial dissimilarity, indicating might belong one community type. can validated input 20 even 50 n.community case study: communities turns clusters sub-figures.","code":"# FIXME: the visual output can be polished later. print(umap_CRM_gradient_plot) umap_CRM_gradient_plot + facet_grid(size_by ~ ., labeller = label_both) umap_CRM_gradient_plot + facet_grid(colour_by ~ size_by, labeller = label_both) umap_CRM_gradient_plot + facet_grid(shape_by ~ size_by, labeller = label_both) umap_CRM_gradient_plot + facet_grid(shape_by ~ colour_by, labeller = label_both)"},{"path":"/articles/miaSim.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"miaSim: Microbiome Data Simulation","text":"miaSim implements tools microbiome data simulation based varying ecological modeling assumptions. can used simulate species abundance matrices, including time series. Detailed function documentation available function reference miaSim package supports R/Bioconductor multi-assay framework. information operating data format microbial ecology, see online tutorial.","code":""},{"path":"/articles/miaSim.html","id":"installation","dir":"Articles","previous_headings":"Introduction","what":"Installation","title":"miaSim: Microbiome Data Simulation","text":"stable Bioconductor release version can installed follows. experimental Bioconductor devel version can installed follows. Load library","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") if (!requireNamespace(\"miaSim\", quietly = TRUE))         BiocManager::install(\"miaSim\") if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") # The following initializes usage of Bioc devel BiocManager::install(version='devel') BiocManager::install(\"miaSim\") library(miaSim)"},{"path":[]},{"path":"/articles/miaSim.html","id":"generate-species-interaction-matrices-for-the-models","dir":"Articles","previous_headings":"Introduction > Examples","what":"Generate species interaction matrices for the models","title":"miaSim: Microbiome Data Simulation","text":"models rely interaction matrices represents interaction heterogeneity species. interaction matrix can generated different distributional assumptions. Generate interactions normal distribution: Generate interactions uniform distribution:","code":"A_normal <- powerlawA(n_species = 4, alpha = 3) A_uniform <- randomA(n_species = 10,                  diagonal = -0.4,                      connectance = 0.5,              interactions = runif(n = 10^2, min = -0.8, max = 0.8))"},{"path":"/articles/miaSim.html","id":"hubbell-model","dir":"Articles","previous_headings":"Introduction > Examples","what":"Hubbell model","title":"miaSim: Microbiome Data Simulation","text":"Hubbell Neutral simulation model characterizes diversity relative abundance species ecological communities assuming migration, births deaths interactions. Losses become replaced migration birth. One can also simulate parameters Hubbell model.","code":"tse_hubbell <- simulateHubbell(n_species = 8,                                M = 10,                    carrying_capacity = 1000,                                k_events = 50,                    migration_p = 0.02,                    t_end = 100) params_hubbell <- simulateHubbellRates(x0 = c(0,5,10),     migration_p = 0.1, metacommunity_probability = NULL, k_events = 1,      growth_rates = NULL, norm = FALSE, t_end=1000)"},{"path":"/articles/miaSim.html","id":"stochastic-logistic-model","dir":"Articles","previous_headings":"Introduction > Examples","what":"Stochastic logistic model","title":"miaSim: Microbiome Data Simulation","text":"Stochastic logistic model used determine dead alive counts community.","code":"tse_logistic <- simulateStochasticLogistic(n_species = 5)"},{"path":"/articles/miaSim.html","id":"self-organised-instability-soi","dir":"Articles","previous_headings":"Introduction > Examples","what":"Self-Organised Instability (SOI)","title":"miaSim: Microbiome Data Simulation","text":"Self-Organised Instability (SOI) model generates time series communities accelerates stochastic simulation.","code":"tse_soi <- simulateSOI(n_species = 4, carrying_capacity = 1000,                        A = A_normal, k_events=5,                x0 = NULL,t_end = 150, norm = TRUE)"},{"path":"/articles/miaSim.html","id":"consumer-resource-model","dir":"Articles","previous_headings":"Introduction > Examples","what":"Consumer-resource model","title":"miaSim: Microbiome Data Simulation","text":"consumer resource model requires randomE function. returns matrix containing production rates consumption rates species. resulting matrix used determination resource consumption efficiency. visualize simulated dynamics using tools miaTime package.","code":"# Consumer-resource model as a TreeSE object tse_crm <- simulateConsumerResource(n_species = 2,                                     n_resources = 4,                                     E = randomE(n_species = 2, n_resources = 4))"},{"path":"/articles/miaSim.html","id":"generalized-lotka-volterra-glv","dir":"Articles","previous_headings":"Introduction > Examples","what":"Generalized Lotka-Volterra (gLV)","title":"miaSim: Microbiome Data Simulation","text":"generalized Lotka-Volterra simulation model generates time-series assuming microbial population dynamics interaction.","code":"tse_glv <- simulateGLV(n_species = 4,                        A = A_normal,                t_start = 0,                         t_store = 1000,                stochastic = FALSE,                norm = FALSE)"},{"path":"/articles/miaSim.html","id":"ricker-model","dir":"Articles","previous_headings":"Introduction > Examples","what":"Ricker model","title":"miaSim: Microbiome Data Simulation","text":"Ricker model discrete version gLV: number species specified interaction matrix must species used models.","code":"tse_ricker <- simulateRicker(n_species=4, A = A_normal, t_end=100, norm = FALSE)"},{"path":"/articles/miaSim.html","id":"data-containers","dir":"Articles","previous_headings":"Introduction","what":"Data containers","title":"miaSim: Microbiome Data Simulation","text":"simulated data sets returned TreeSummarizedExperiment objects. provides access broad range tools microbiome analysis support format (see microbiome.github.io). examples object manipulation analysis can found OMA Online Manual. instance, plot population density can use miaViz package:","code":""},{"path":"/articles/miaSim.html","id":"case-studies","dir":"Articles","previous_headings":"Introduction","what":"Case studies","title":"miaSim: Microbiome Data Simulation","text":"Source code replicating published case studies using miaSim package (Gao et al. 2023) available Github (based phyloseq data container).","code":""},{"path":"/articles/miaSim.html","id":"related-work","dir":"Articles","previous_headings":"Introduction","what":"Related work","title":"miaSim: Microbiome Data Simulation","text":"micodymora Python package microbiome simulation","code":""},{"path":"/articles/miaSim.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"miaSim: Microbiome Data Simulation","text":"","code":"sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.2 LTS ##  ## Matrix products: default ## BLAS:   /home/xxx/bin/R-4.3.0/lib/libRblas.so  ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Europe/Mariehamn ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] miaSim_1.7.7                   TreeSummarizedExperiment_2.8.0 ##  [3] Biostrings_2.68.1              XVector_0.40.0                 ##  [5] SingleCellExperiment_1.22.0    SummarizedExperiment_1.30.2    ##  [7] Biobase_2.60.0                 GenomicRanges_1.52.0           ##  [9] GenomeInfoDb_1.36.1            IRanges_2.34.1                 ## [11] S4Vectors_0.38.1               BiocGenerics_0.46.0            ## [13] MatrixGenerics_1.12.2          matrixStats_1.0.0              ## [15] BiocStyle_2.28.0               ##  ## loaded via a namespace (and not attached): ##  [1] xfun_0.39               bslib_0.5.0             poweRlaw_0.70.6         ##  [4] lattice_0.21-8          yulab.utils_0.0.6       vctrs_0.6.3             ##  [7] tools_4.3.0             bitops_1.0-7            generics_0.1.3          ## [10] parallel_4.3.0          tibble_3.2.1            fansi_1.0.4             ## [13] pkgconfig_2.0.3         Matrix_1.5-4.1          desc_1.4.2              ## [16] lifecycle_1.0.3         GenomeInfoDbData_1.2.10 compiler_4.3.0          ## [19] stringr_1.5.0           treeio_1.24.1           textshaping_0.3.6       ## [22] codetools_0.2-19        htmltools_0.5.5         sass_0.4.6              ## [25] lazyeval_0.2.2          RCurl_1.98-1.12         yaml_2.3.7              ## [28] pracma_2.4.2            tidyr_1.3.0             pkgdown_2.0.7           ## [31] pillar_1.9.0            crayon_1.5.2            jquerylib_0.1.4         ## [34] BiocParallel_1.34.2     DelayedArray_0.26.6     cachem_1.0.8            ## [37] nlme_3.1-162            tidyselect_1.2.0        digest_0.6.33           ## [40] stringi_1.7.12          dplyr_1.1.2             purrr_1.0.1             ## [43] bookdown_0.34           rprojroot_2.0.3         fastmap_1.1.1           ## [46] grid_4.3.0              cli_3.6.1.9000          magrittr_2.0.3          ## [49] S4Arrays_1.0.4          utf8_1.2.3              ape_5.7-1               ## [52] rmarkdown_2.22          deSolve_1.35            ragg_1.2.5              ## [55] memoise_2.0.1           evaluate_0.21           knitr_1.43              ## [58] rlang_1.1.1             Rcpp_1.0.11             tidytree_0.4.2          ## [61] glue_1.6.2              BiocManager_1.30.21     jsonlite_1.8.7          ## [64] R6_2.5.1                systemfonts_1.0.4       fs_1.6.2                ## [67] zlibbioc_1.46.0"},{"path":"/articles/phyloseq/caseStudy1-SIS.html","id":"introduction","dir":"Articles > Phyloseq","previous_headings":"","what":"Introduction","title":"caseStudy1-SIS-phyloseq","text":"document provides detailed code required replicate case study 1 discussed Gao et al. (2023). Methods Ecology Evolution. DOI: 10.1111/2041-210X.14129 replication study implemented phyloseq. TreeSE package since upgraded use TreeSE data container. general instructions examples using miaSim package tools, see vignette. miaSim implements tools microbiome data simulation based different ecological modeling assumptions. can used simulate species abundance matrices, including time series. detailed function documentation, see function reference page","code":""},{"path":"/articles/phyloseq/caseStudy1-SIS.html","id":"case-study-1-strongly-interacting-species-sis-explaining-community-types","dir":"Articles > Phyloseq","previous_headings":"","what":"Case study 1: Strongly interacting species (SIS) explaining community types","title":"caseStudy1-SIS-phyloseq","text":"(Reference: Origins Control Community Types Human Microbiome) aim case study recalculate Figure 2 demonstrates occurrence SIS clustering results communities. figure, left right, different power-law distributions (defined alpha = 7, 3, 2, 1.6, 1.01) controls strength frequency inter-species interactions. second row, inter-species interactions visualized networks. third row, different clustering results PCoA demonstrated. case study, used sets parameters, acquired similar results.","code":""},{"path":"/articles/phyloseq/caseStudy1-SIS.html","id":"setup","dir":"Articles > Phyloseq","previous_headings":"Case study 1: Strongly interacting species (SIS) explaining community types","what":"Setup","title":"caseStudy1-SIS-phyloseq","text":"Let us load dependencies Define function generate power-law distribution Load parameters used Gibson et al. Create variables store results","code":"library(ggplot2) library(igraph) library(colourvalues) library(GGally) library(network) library(sna) library(dplyr) library(philentropy) library(cluster) library(ape) library(intergraph) library(umap) library(miaSim) rpower <- function(n, alpha, norm = FALSE) {   u <- runif(n, min = 0, max = 1 - .Machine$double.eps^0.5)   power <- (1 - u)^(1 / (1 - alpha))   if (norm) {     return(power / mean(power))   } else {     return(power)   } } params <- data.frame(   alpha = c(7, 3, 2, 1.6, 1.01),   t_end = c(20, 10, 5, 2, 1),   t_step = c(0.02, 0.01, 0.005, 0.002, 0.001) ) set.seed(42) n_species <- 100 H <- list() df <- list() plot_hist <- list() N <- list() interactions_custom <- list() A <- list() g <- list() g_plot <- list() local_species_pool <- list() local_A <- list()"},{"path":"/articles/phyloseq/caseStudy1-SIS.html","id":"generate-constants-and-plot-different-distributions","dir":"Articles > Phyloseq","previous_headings":"Case study 1: Strongly interacting species (SIS) explaining community types","what":"Generate constants and plot different distributions","title":"caseStudy1-SIS-phyloseq","text":"Identify SIS using H[[row]] Simulate GLV models using different growth rates 4 scenarios first scenario original one Gibson et al., rest explorations (second scenario assigning various growth rates random species; third scenario assigning faster growth rate SIS; fourth scenario assigning faster growth rate non-SIS). Different scenarios implemented overwriting default random growth rates simulation function. Let us prepare result lists scenarios. case study, focus first scenario. (explore , simply remove first line, put code loop like (scenario seq_along(scenarios)) {...} .) Validate relationship cluster SIS compare previous PCoA results PCoA results rendered /without SIS, can find last figures (alpha = 1.6 alpha=1.01, ’s one SIS), community types clustered way rendered /without SIS, indicating occurrence SIS can influence community types.","code":"set.seed(42) for (row in seq_len(nrow(params))) {   # for each power-law distribution   print(paste(\"row =\", row))    H[[row]] <- rpower(n = n_species, alpha = params$alpha[row], norm = TRUE)   df[[row]] <- data.frame(H[[row]])   plot_hist[[row]] <- ggplot(df[[row]], aes(H[[row]])) +     ggtitle(paste(\"alpha =\", params$alpha[[row]])) +     geom_histogram(fill = \"steelblue\", color = \"grey20\", bins = 10) +     scale_y_log10(breaks = c(1, 10, 100), limits = c(1, 100)) +     theme_bw() +      theme(plot.title = element_text(hjust = 0.5))      # plot_hist[[row]]   print(plot_hist[[row]])    N[[row]] <- matrix(rnorm(n = n_species^2, mean = 0, sd = 1), nrow = n_species)   diag(N[[row]]) <- 0   interactions_custom[[row]] <- N[[row]] %*% diag(H[[row]])   A[[row]] <- randomA(     n_species = 100,     diagonal = -1,     scale_off_diagonal = 0.07,     connectance = 1,     interactions = interactions_custom[[row]]   )   g[[row]] <- graph_from_adjacency_matrix(A[[row]], weighted = TRUE, diag = FALSE)   print(paste(\"max edge weight =\", max(E(g[[row]])$weight)))   rev_viridis <- get_palette(\"viridis\")[rev(seq_len(nrow(get_palette(\"viridis\")))), ]   E(g[[row]])$color <- head(colour_values(c(abs(E(g[[row]])$weight), 0), palette = rev_viridis, alpha = 0, include_alpha = TRUE), -1)   g_plot[[row]] <- ggnet2(     net = g[[row]],     mode = \"circle\",     node.color = \"black\",     node.size = 1,     edge.color = \"color\", edge.alpha = 0.25   ) +      ggtitle(paste(\"alpha =\", params$alpha[[row]])) +      theme(plot.title = element_text(hjust = 0.5))   # g_plot[[row]]   print(g_plot[[row]])    local_species_pool[[row]] <- list()   local_A[[row]] <- list()    for (local_community in seq_len(100)) {     local_species_pool[[row]][[local_community]] <- sample(x = 100, size = 80)     local_A[[row]][[local_community]] <- A[[row]][local_species_pool[[row]][[local_community]], local_species_pool[[row]][[local_community]]]   }   # save histogram and network plots ####   # ggsave(paste0(\"hist\", params$alpha[row], \".pdf\"), plot = plot_hist[[row]], dpi = 300, width = 6, height = 6, units = \"cm\")   # ggsave(paste0(\"net\", params$alpha[row], \".pdf\"), plot = g_plot[[row]], dpi = 300, width = 6, height = 6, units = \"cm\") } ## [1] \"row = 1\" ## [1] \"max edge weight = 0.42198663955657\" ## [1] \"row = 2\" ## [1] \"max edge weight = 1.14350270284621\" ## [1] \"row = 3\" ## [1] \"max edge weight = 12.6240910282149\" ## [1] \"row = 4\" ## [1] \"max edge weight = 11.4025806066921\" ## [1] \"row = 5\" ## [1] \"max edge weight = 19.1461396036079\" SIS <- list() group_sis <- list() for (row in seq_len(nrow(params))) {   SIS[[row]] <- head(order(H[[row]], decreasing = TRUE), 1)   group_sis[[row]] <- list()   for (local_community in seq_len(100)) {     if (paste0(\"sp\", SIS[[row]]) %in% rownames(local_A[[row]][[local_community]])) {       group_sis[[row]][[local_community]] <- \"with SIS\"     } else {       group_sis[[row]][[local_community]] <- \"without SIS\"     }   }   group_sis[[row]] <- unlist(group_sis[[row]]) } simulation_GLV <- list() otu_table <- list() jsd <- list() PCoA <- list() PCoA_coord <- list() bestk <- list() PAM <- list() SI <- list() groups <- list() pcoa_plot <- list() dfs_to_bind <- list()  scenarios <- c(\"original\", \"various growth rates\", \"SIS grows faster\", \"non-SIS grows faster\") growthRates <- vector(mode = \"list\", length = 4) growthRates[[1]] <- rep(1, 80) growthRates[[2]] <- NULL # growthRates for scenario 3 and 4 are assigned in the following loop  customPalette <- c(\"#d95319\", \"#0072bd\", \"#edb120\", \"#7e2f8e\") scenario <- 1   print(paste0(\"scenario: \", scenarios[scenario]))    ### make new lists ####   simulation_GLV[[scenario]] <- list()   otu_table[[scenario]] <- list()   jsd[[scenario]] <- list()   PCoA[[scenario]] <- list()   PCoA_coord[[scenario]] <- list()   bestk[[scenario]] <- list()   PAM[[scenario]] <- list()   SI[[scenario]] <- list()   groups[[scenario]] <- list()   pcoa_plot[[scenario]] <- list()    ### run simulations ####   for (row in seq_len(nrow(params))) {     simulation_GLV[[scenario]][[row]] <- list()     otu_table[[scenario]][[row]] <- data.frame(matrix(nrow = 0, ncol = 100))     colnames(otu_table[[scenario]][[row]]) <- paste0(\"sp\", 1:100)     dfs_to_bind[[scenario]] <- list()      #### overwrite growth rates ####     for (local_community in seq_len(100)) {       if (scenario == 3) {         growthRates[[scenario]] <- 9.9 * local_species_pool[[row]][[local_community]] == SIS[[row]] + 0.1       }       if (scenario == 4) {         growthRates[[scenario]] <- -9.9 * local_species_pool[[row]][[local_community]] == SIS[[row]] + 10       }        simulation_GLV[[scenario]][[row]][[local_community]] <- simulateGLV(         n_species = 80,         names_species = paste0(\"sp\", local_species_pool[[row]][[local_community]]),         A = local_A[[row]][[local_community]],         x0 = rep(1, 80),         growth_rates = growthRates[[scenario]],         t_end = params$t_end[row],         t_step = params$t_step[row],         stochastic = FALSE,         norm = TRUE       )        # makePlot(simulation_GLV[[scenario]][[row]][[local_community]]$matrix)       dfs_to_bind[[scenario]] <- append(dfs_to_bind[[scenario]], list(simulation_GLV[[scenario]][[row]][[local_community]]$matrix[time = 1000, ]))     }      ### form otu tables ####     otu_table[[scenario]][[row]] <- bind_rows(dfs_to_bind[[scenario]])     otu_table[[scenario]][[row]] <- otu_table[[scenario]][[row]][, setdiff(colnames(otu_table[[scenario]][[row]]), \"time\")] # Remove time column     otu_table[[scenario]][[row]][is.na(otu_table[[scenario]][[row]])] <- 0      ### calculate jensen-shannon distance and plot PCoA ####     jsd[[scenario]][[row]] <- JSD(as.matrix(otu_table[[scenario]][[row]]))     PCoA[[scenario]][[row]] <- ape::pcoa(as.dist(jsd[[scenario]][[row]]))     PCoA_coord[[scenario]][[row]] <- PCoA[[scenario]][[row]]$vectors[, 1:2]     colnames(PCoA_coord[[scenario]][[row]]) <- c(\"PCo1\", \"PCo2\")      bestk[[scenario]][[row]] <- 2     PAM[[scenario]][[row]] <- pam(PCoA[[scenario]][[row]]$vectors, k = 2)     SI[[scenario]][[row]] <- PAM[[scenario]][[row]]$silinfo$avg.width      for (k in 3:10) {       PAMtemp <- pam(PCoA[[scenario]][[row]]$vectors, k = k)       if (PAMtemp$silinfo$avg.width > SI[[scenario]][[row]]) {         SI[[scenario]][[row]] <- PAMtemp$silinfo$avg.width         bestk[[scenario]][[row]] <- k         PAM[[scenario]][[row]] <- PAMtemp       }     }      groups[[scenario]][[row]] <- factor(PAM[[scenario]][[row]]$clustering)      dataframe_pcoa <- as.data.frame(PCoA_coord[[scenario]][[row]])     dataframe_pcoa$group <- groups[[scenario]][[row]]     pcoa_plot[[scenario]][[row]] <- ggplot(       dataframe_pcoa,       aes(x = PCo1, y = PCo2, color = group)     ) +       ggtitle(paste(\"scenario\", scenario, scenarios[scenario], \";\", \"alpha =\", params$alpha[[row]])) +       geom_point() +       # coord_fixed(xlim = c(-1, 1), ylim = c(-1, 1)) +       theme_bw() +       scale_color_manual(values = customPalette) +       theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5))     print(pcoa_plot[[scenario]][[row]])   } pcoa_plot_sis <- list() for (row in seq_len(nrow(params))) {   pcoa_plot_sis[[row]] <- ggplot(as.data.frame(PCoA_coord[[1]][[row]]), aes(x = PCo1, y = PCo2)) +     geom_point(aes(color = group_sis[[row]])) +     ggtitle(paste(\"alpha =\", params$alpha[[row]])) +     theme_bw() +      theme(plot.title = element_text(hjust = 0.5))   print(pcoa_plot_sis[[row]])    # ggsave(paste0(\"pcoa_validation_\", params$alpha[row], \".pdf\"), plot = pcoa_plot_sis[[row]], dpi = 300, width = 6, height = 6, units = \"cm\") }"},{"path":"/articles/phyloseq/caseStudy2-NutrientThreshold.html","id":"introduction","dir":"Articles > Phyloseq","previous_headings":"","what":"Introduction","title":"caseStudy2-NutrientThreshold-phyloseq","text":"document provides detailed code required replicate case study 2 discussed Gao et al. (2023). Methods Ecology Evolution. DOI: 10.1111/2041-210X.14129 replication study implemented phyloseq. TreeSE package since upgraded use TreeSE data container. general instructions examples using miaSim package tools, see vignette. miaSim implements tools microbiome data simulation based different ecological modeling assumptions. can used simulate species abundance matrices, including time series. detailed function documentation, see function reference page","code":""},{"path":"/articles/phyloseq/caseStudy2-NutrientThreshold.html","id":"case-study-2-nutrient-concentration-threshold","dir":"Articles > Phyloseq","previous_headings":"","what":"Case study 2: Nutrient concentration threshold","title":"caseStudy2-NutrientThreshold-phyloseq","text":"(Reference: Available energy fluxes drive transition diversity, stability, functional structure microbial communities) aim case study design demonstrate existence nutrient concentration threshold limits beta-diversity communities. fulfill aim, designed gradient environments, well gradient communities.","code":""},{"path":"/articles/phyloseq/caseStudy2-NutrientThreshold.html","id":"setup","dir":"Articles > Phyloseq","previous_headings":"Case study 2: Nutrient concentration threshold","what":"Setup","title":"caseStudy2-NutrientThreshold-phyloseq","text":"Load dependencies (batch simulations time-consuming. reduce calculation burden, decreased numbers environments, resources, communities original 10 5, made minor modifications.) Set random seed Set initial shared parameters Define generating function. function generates data frame, row arranged increasing dissimilarity first row. Generate communities Load plotting functions   Initialize shared parameters Generate resource gradients","code":"library(ggplot2) library(vegan) library(reshape2) library(umap) library(miaSim) library(philentropy) library(ape) library(cluster) set.seed(42) n_species <- 5 n_resources <- 5 E <- randomE(n_species, n_resources, mean_consumption = 1, mean_production = 3) growth_rates <- runif(n_species) monod_constant <- matrix(rbeta(n_species*n_resources, 10,10),nrow=n_species, ncol=n_resources) t_store <- 50 n.instances <- 1 # no stochastic process: no need to repeat gradient.df.generator <- function(n_row, n_col, density_row, max_gradient, error_interval){     list_initial <- list()     dissimilarity.gradient <- seq(from = 0, to = max_gradient, length.out = n_row)     for (i in seq_len(n_row)){         print(i)         if (i == 1){             row_temp <- rbeta(n_col, 1, 1/n_col)             col_to_remove <- sample(x = seq_len(n_col), size = n_col-n_col*density_row)             row_temp[col_to_remove] <- 0             list_initial[[i]] <- row_temp         } else {             while (length(list_initial) < i) {                 row_temp <- rbeta(n_col, 1, 1/n_col)                 col_to_remove <- sample(x = seq_len(n_col), size = n_col-n_col*density_row)                 row_temp[col_to_remove] <- 0                 diff_temp <- abs(vegdist(rbind(list_initial[[1]], row_temp), method = \"bray\") - dissimilarity.gradient[i])                 if (diff_temp < error_interval) {                     list_initial[[i]] <- row_temp                 }             }         }     }     dataframe_to_return <- as.data.frame(t(matrix(unlist(list_initial), ncol = n_row)))     return(dataframe_to_return) } n.community <- 5 # you can also try 20 or even 50. density.community <- 0.8 set.seed(42) community.initial.df <- gradient.df.generator(n_row = n.community, n_col = n_species, density_row = density.community, max_gradient = 0.7, error_interval = 0.1) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 dist.community.initial.df <- vegdist(community.initial.df, method = \"bray\") makePlot <- function(out_matrix, title = \"abundance of species by time\", obj = \"species\", y.label = \"x.t\"){     df <- as.data.frame(out_matrix)     dft <-  melt(df, id=\"time\")     names(dft)[2] = obj     names(dft)[3] = y.label     lgd = ncol(df)<= 20     ggplot(dft, aes_string(names(dft)[1], names(dft)[3], col = names(dft)[2])) +         geom_line(show.legend = lgd, lwd=0.5) +         ggtitle(title) +         theme_linedraw() +         theme(plot.title = element_text(hjust = 0.5, size = 14)) } makePlotRes <- function(out_matrix, title = \"quantity of compounds by time\"){     df <- as.data.frame(out_matrix)     dft <-  melt(df, id=\"time\")     names(dft)[2] = \"resources\"     names(dft)[3] = \"S.t\"     lgd = ncol(df)<= 20     ggplot(dft, aes(time, S.t, col = resources)) +         geom_line(show.legend = lgd, lwd=0.5) +         ggtitle(title) +         theme_linedraw() +         theme(plot.title = element_text(hjust = 0.5, size = 14)) } makeHeatmap <-function(matrix.A,                        title = \"Consumption/production matrix\",                        y.label = 'resources',                        x.label = 'species',                        midpoint_color = NULL,                        lowColor = \"red\",                        midColor = \"white\",                        highColor = \"blue\"){     df <- melt(t(matrix.A))     if (is.null(midpoint_color)) {         midpoint_color <- 0     }     names(df)<- c(\"x\", \"y\", \"strength\")     df$y <- factor(df$y, levels=rev(unique(sort(df$y))))     fig <- ggplot(df, aes(x,y,fill=strength)) + geom_tile() + coord_equal() +         theme(axis.title = element_blank()) +         scale_fill_gradient2('strength', low = lowColor, mid = midColor, high = highColor, midpoint = midpoint_color)+         theme_void() + ggtitle(title)      if (ncol(matrix.A)<=10 & nrow(matrix.A)<=10){         fig <- fig + geom_text(aes(label = round(strength, 2)))     } else if (ncol(matrix.A)<=15 & nrow(matrix.A)<=15){         fig <- fig + geom_text(aes(label = round(strength, 1)))     } else {         fig <- fig     }      fig <- fig + labs(x = x.label, y = y.label)+         theme_linedraw() +         theme(plot.title = element_text(hjust = 0.5, size = 14), axis.text.x = element_text(             angle = 90))      if (nrow(matrix.A) >= 20){         # too many species         fig <- fig + theme(             axis.title.y=element_blank(),             axis.text.y=element_blank(),             axis.ticks.y=element_blank(),         )     }     if (ncol(matrix.A) >= 20){         # too many resources         fig <- fig + theme(             axis.title.x=element_blank(),             axis.text.x=element_blank(),             axis.ticks.x=element_blank()         )     }     fig } makeUMAP <- function(matrix, n_neighbors=10, min_dist=0.1, gradient=NULL, gradient_title = 'gradient', group=NULL, group2=NULL){     custom.config = umap.defaults     custom.config$n_neighbors = n_neighbors     custom.config$min_dist = min_dist      df <- as.data.frame(umap(matrix,config = custom.config)$layout)     df$gradient <- gradient      if (is.null(gradient)){         df$gradient <- 1      }     colnames(df) = c('UMAP_2', 'UMAP_1', gradient_title)     if (is.null(group)){         ggplot(df, aes_string('UMAP_2', 'UMAP_1', color=gradient_title)) +             geom_point() +             scale_color_gradient(low=\"blue\", high=\"red\")     } else {         if (is.null(group2)){             ggplot(df, aes_string('UMAP_2', 'UMAP_1', color=gradient_title)) +                 geom_point(aes(color = group)) + theme_bw()         } else {             ggplot(df, aes_string('UMAP_2', 'UMAP_1', color=gradient_title)) +                 geom_point(aes(color = group, shape = group2)) + theme_bw()         }     } }  makeHeatmap(as.matrix(dist.community.initial.df),             title = \"dissimilarity matrix\",             x.label = \"community.1\",             y.label = \"community.2\") makeUMAP(matrix = community.initial.df,          n_neighbors = 5,          group = factor(seq_len(n.community)),          gradient_title = \"community\") crm_params <- list(     n_species = n_species,     n_resources = n_resources,     x0 = NULL,     E = E,     resources = rep(1,n_resources),     monod_constant = monod_constant,     migration_p = 0,     stochastic = FALSE,     t_start = 0,     t_end = 50,     t_step = 1,     t_store = t_store,     growth_rates = growth_rates,     norm=FALSE) resourceConcentration <- 10^seq(0,4,1) # 1 to 10000 n.medium <- 5 density.medium <- 0.8 set.seed(42) resource.initial.df <- gradient.df.generator(n_row = n.medium, n_col = n_resources, density_row = density.medium, max_gradient = 0.7, error_interval = 0.1) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5"},{"path":"/articles/phyloseq/caseStudy2-NutrientThreshold.html","id":"test-one-run","dir":"Articles > Phyloseq","previous_headings":"Case study 2: Nutrient concentration threshold","what":"test one run","title":"caseStudy2-NutrientThreshold-phyloseq","text":"Generate simulations store final community community.simulation. step, final relative abundance table basisComposition_prop","code":"crmExample <- simulateConsumerResource(     n_species = n_species,     n_resources = n_resources,     E = E,     x0 = as.numeric(community.initial.df[1,]),     resources = as.numeric(resourceConcentration[3]*resource.initial.df[1,]),     growth_rates = growth_rates,     monod_constant = monod_constant,     stochastic = FALSE,     t_end = 50,     t_step = 1,     t_store = 50,     norm = FALSE) makePlot(crmExample$matrix) makePlotRes(crmExample$resources) set.seed(42) library(miaSim) community.simulation <- list() counter_i <- 1 for (resConc in resourceConcentration) {     for (medium in seq_len(n.medium)){         crm_params$resources <- as.numeric(resource.initial.df[medium,]*resConc)         paramx0 <- as.list(as.data.frame(t(community.initial.df)))         crm_param_iter <- list(x0 = paramx0)         print(paste(\"resConc\", resConc, \"medium\", medium))         crmMoments <- generateSimulations(model = \"simulateConsumerResource\",                                           params_list = crm_params,                                           param_iter = crm_param_iter,                                           n_instances = n.instances,                                           t_end = 50)         community.simulation[[counter_i]] <- as.data.frame(do.call(rbind, lapply(crmMoments, getCommunity)))         counter_i <- counter_i +1     } } basisComposition <- do.call(rbind.data.frame, community.simulation) rm(counter_i, community.simulation) basisComposition_prop <- basisComposition / rowSums(basisComposition)"},{"path":"/articles/phyloseq/caseStudy2-NutrientThreshold.html","id":"visualization","dir":"Articles > Phyloseq","previous_headings":"Case study 2: Nutrient concentration threshold","what":"Visualization","title":"caseStudy2-NutrientThreshold-phyloseq","text":"Make UMAP plots. step, plot result stored umap_CRM_gradient_plot, visualized different facets. part, different visualization results demonstrate (various facets) gradual change communities’ beta diversity. first figure indicates initial community composition important combinations initial available resources. first sub-figure second figure demonstrates oligotrophic (less available nutrients) environment, communities won’t change much given time, whilst last two sub-figures resemble , implying nutrient longer limiting factor beta-diversity community. pattern displayed following “curve plot”. third figure, second fourth community always stays similar, despite initial dissimilarity, indicating might belong one community type. can validated input 20 even 50 n.community case study: communities turns clusters sub-figures. “Saturation curve” average beta-diversity communities community 1 part, ’d like demonstrate average distance communities community 1 reach threshold nutrients, average distance won’t increase along total concentration nutrients. , first define function calculating mean distance first community. Construct function taking umap_CRM_coor df return mean distance Constructing dataframe save results Visualize distance plot","code":"concentration <- as.factor(rep(resourceConcentration, each = n.medium*n.community)) medium <- as.factor(rep(seq_len(n.medium), each = n.community ,times = length(resourceConcentration) )) community <- as.factor(rep(seq_len(n.community), times = length(resourceConcentration)*n.medium))  #plot the result in a UMAP space makeUMAP(basisComposition, group = medium, group2 = concentration, gradient_title = 'Medium') umap_CRM_gradient <- umap(basisComposition_prop) # umap_CRM_gradient <- umap(basisComposition) umap_CRM_coor <- as.data.frame(umap_CRM_gradient$layout) colnames(umap_CRM_coor) <- c(\"UMAP_1\", \"UMAP_2\") umap_CRM_coor <- cbind(umap_CRM_coor, concentration, medium, community) umap_CRM_gradient_plot <- ggplot(umap_CRM_coor,                                  aes(UMAP_1, UMAP_2,                                      # alpha = concentration,                                      color = medium,                                      shape = community)) +     geom_point() +     # scale_shape_manual(values = c(0, 1, 2, 5, 6, 8, 15, 16, 17, 18)) +     scale_shape_manual(values = seq(0, n.community -1 ,1)) +     scale_alpha_manual(values = seq(0.25, 1, 0.75/(length(resourceConcentration)-1))) +     theme_bw() print(umap_CRM_gradient_plot)  print(umap_CRM_gradient_plot + facet_grid(concentration ~ ., labeller = label_both))  print(umap_CRM_gradient_plot + facet_grid(medium ~ concentration, labeller = label_both))  print(umap_CRM_gradient_plot + facet_grid(community ~ concentration, labeller = label_both))  print(umap_CRM_gradient_plot + facet_grid(community ~ medium, labeller = label_both)) average_distance <- function(df, res_conc_type, com_type, method = \"euclidean\"){     sub_df <- df[df$concentration == res_conc_type & df$community == com_type,]     combines <- combn(sub_df$medium, 2)     distances <- NULL     for (i in seq_len(ncol(combines))) {         distances[i] <- dist(sub_df[combines[,i], c(1, 2)])     }     # print(distances)     return(mean(distances)) } # average_distance(umap_CRM_coor, 1, 2) distance_saturation_data <- data.frame(concentration = integer(),                                        community = integer(),                                        average_distance = numeric())  for (res_conc_type in unique(umap_CRM_coor$concentration)){     for (com_type in unique(umap_CRM_coor$community)){         ave_dist <- average_distance(umap_CRM_coor, res_conc_type, com_type)         distance_saturation_data[nrow(distance_saturation_data)+1,] <-             c(res_conc_type, com_type, ave_dist)     } } # View(distance_saturation_data) distance_saturation_data$average_distance <- as.numeric(distance_saturation_data$average_distance) distance_saturation_data$concentration <- as.factor(distance_saturation_data$concentration) distance_saturation_data$community <- as.factor(distance_saturation_data$community) distance_saturation_data_plot <- ggplot(distance_saturation_data,                                  aes(concentration, average_distance,                                      color = community,                                      group = community)) +     geom_line() + geom_point() +     scale_shape_manual(values = c(0, 1, 2, 5, 6, 8, 15, 16, 17, 18)) +     labs(x = \"resource concentration\", y = \"average distance between communities in UMAP\") +     theme_bw() print(distance_saturation_data_plot) # ggsave(paste0(\"CRMgradient_distance_curve_mod.pdf\"), plot = distance_saturation_data_plot , dpi = 300, width = 12, height = 10, units = \"cm\", scale = 2)"},{"path":"/articles/phyloseq/caseStudy3-EnvironmentalComplexity.html","id":"introduction","dir":"Articles > Phyloseq","previous_headings":"","what":"Introduction","title":"caseStudy3-EnvComplexity-phyloseq","text":"document provides detailed code required replicate case study 3 discussed Gao et al. (2023). Methods Ecology Evolution. DOI: 10.1111/2041-210X.14129 replication study implemented phyloseq. TreeSE package since upgraded use TreeSE data container. general instructions examples using miaSim package tools, see vignette. miaSim implements tools microbiome data simulation based different ecological modeling assumptions. can used simulate species abundance matrices, including time series. detailed function documentation, see function reference page","code":""},{"path":"/articles/phyloseq/caseStudy3-EnvironmentalComplexity.html","id":"case-study-3-environmental-complexity-impacts-on-different-communities","dir":"Articles > Phyloseq","previous_headings":"","what":"Case study 3: Environmental complexity impacts on different communities","title":"caseStudy3-EnvComplexity-phyloseq","text":"(Reference: Non-additive microbial community responses environmental complexity) aim case study recalculate patterns shown existing publication reference. specifically, left part Figure 2. case study, consumer-resource model used. number species 3 distinct communities varied communities named number species (.e. com13, com3, com4). community, floor different numbers carbon resources (nutrients) set 1, 2, 4, 8, 16, 32. original experiment, value OD600 selected y-axis represent growth yield. simulations, however, total number organisms(number individuals) used reflect growth yield.","code":""},{"path":"/articles/phyloseq/caseStudy3-EnvironmentalComplexity.html","id":"setup","dir":"Articles > Phyloseq","previous_headings":"Case study 3: Environmental complexity impacts on different communities","what":"Setup","title":"caseStudy3-EnvComplexity-phyloseq","text":"Load dependencies Set random seed Set number repeats Initial output dataframes store data Generating function. function generates data frame, row arranged increasing dissimilarity first row. Load parameters used Pacheco et al., initialized community data frame. Note step, value range theta extended. Loop different combinations (number species X theta X number repetations X number resources)","code":"library(ggplot2) library(miaSim) library(vegan) library(ggplot2) library(reshape2) set.seed(42) n_rep <- 50 result_df <- data.frame(     n_species = integer(),     theta = numeric(),     i = integer(),     n_resources = integer(),     value = numeric() )  result_df2 <- data.frame(   matrix(NA, nrow = 0, ncol = 13, dimnames = list(NULL, paste0(\"sp\", seq_len(13)))) )  sorensen_df <- data.frame(     n_species = integer(),     theta = numeric(),     rho_mean = numeric(),     rho_sd = numeric() ) gradient_df_generator <- function(n_row, n_col, density_row, max_gradient, error_interval){   list_initial <- list()   dissimilarity.gradient <- seq(from = 0, to = max_gradient, length.out = n_row)   for (i in seq_len(n_row)){     print(i)     if (i == 1){       row_temp <- rbeta(n_col, 1, n_col)       col_to_remove <- sample(x = seq_len(n_col), size = n_col-n_col*density_row)       row_temp[col_to_remove] <- 0       list_initial[[i]] <- row_temp     } else {       while (length(list_initial) < i) {         row_temp <- rbeta(n_col, 1, n_col)         col_to_remove <- sample(x = seq_len(n_col), size = n_col-n_col*density_row)         row_temp[col_to_remove] <- 0         diff_temp <- abs(vegdist(rbind(list_initial[[1]], row_temp), method = \"bray\") - dissimilarity.gradient[i])         if (diff_temp < error_interval) {           list_initial[[i]] <- row_temp         }       }     }   }   dataframe_to_return <- as.data.frame(t(matrix(unlist(list_initial), ncol = n_row)))   return(dataframe_to_return) } n_species_types <- c(13, 3, 4) theta_types <- c(1, 0.75, 0.5, 0.25, 0.1, 0.05) n_resources_types <- c(1,2,4,8,16,32)  community.initial.df <- as.list(   lapply(n_species_types,           gradient_df_generator,           n_row = n_rep,           density_row = 1,          max_gradient = 0.7,          error_interval = 0.15) ) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 ## [1] 12 ## [1] 13 ## [1] 14 ## [1] 15 ## [1] 16 ## [1] 17 ## [1] 18 ## [1] 19 ## [1] 20 ## [1] 21 ## [1] 22 ## [1] 23 ## [1] 24 ## [1] 25 ## [1] 26 ## [1] 27 ## [1] 28 ## [1] 29 ## [1] 30 ## [1] 31 ## [1] 32 ## [1] 33 ## [1] 34 ## [1] 35 ## [1] 36 ## [1] 37 ## [1] 38 ## [1] 39 ## [1] 40 ## [1] 41 ## [1] 42 ## [1] 43 ## [1] 44 ## [1] 45 ## [1] 46 ## [1] 47 ## [1] 48 ## [1] 49 ## [1] 50 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 ## [1] 12 ## [1] 13 ## [1] 14 ## [1] 15 ## [1] 16 ## [1] 17 ## [1] 18 ## [1] 19 ## [1] 20 ## [1] 21 ## [1] 22 ## [1] 23 ## [1] 24 ## [1] 25 ## [1] 26 ## [1] 27 ## [1] 28 ## [1] 29 ## [1] 30 ## [1] 31 ## [1] 32 ## [1] 33 ## [1] 34 ## [1] 35 ## [1] 36 ## [1] 37 ## [1] 38 ## [1] 39 ## [1] 40 ## [1] 41 ## [1] 42 ## [1] 43 ## [1] 44 ## [1] 45 ## [1] 46 ## [1] 47 ## [1] 48 ## [1] 49 ## [1] 50 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 ## [1] 12 ## [1] 13 ## [1] 14 ## [1] 15 ## [1] 16 ## [1] 17 ## [1] 18 ## [1] 19 ## [1] 20 ## [1] 21 ## [1] 22 ## [1] 23 ## [1] 24 ## [1] 25 ## [1] 26 ## [1] 27 ## [1] 28 ## [1] 29 ## [1] 30 ## [1] 31 ## [1] 32 ## [1] 33 ## [1] 34 ## [1] 35 ## [1] 36 ## [1] 37 ## [1] 38 ## [1] 39 ## [1] 40 ## [1] 41 ## [1] 42 ## [1] 43 ## [1] 44 ## [1] 45 ## [1] 46 ## [1] 47 ## [1] 48 ## [1] 49 ## [1] 50 for (n_species in n_species_types){     for (theta in theta_types) {         sorensen <- c()         for (i in seq_len(n_rep)){             for (n_resources in n_resources_types) {                 ### generate E ####                 Etest <- randomE(n_species = n_species,                                  n_resources = n_resources,                                  mean_consumption = theta*n_resources,                                  exact = TRUE)                  ### calculate rho ####                 if (n_resources == max(n_resources_types)){                     Etest_pos <- Etest                     Etest_pos[Etest_pos<0] <- 0                     for (j in seq_len(n_species - 1)){                         for (k in 2:n_species){                             sorensen <- c(sorensen,                                           sum(apply(Etest_pos[c(j,k),], 2, min)))                         }                     }                 }                  if (n_resources > 1){                     Priority <- t(apply(matrix(sample(n_species * n_resources), nrow = n_species), 1, order))                     Priority <- (Etest > 0) * Priority                 } else {                     Priority <- NULL                 }                  print(paste0(\"n_species=\",n_species, \" theta=\",theta, \" i=\", i, \" n_resources=\", n_resources))                 x0temp <- as.numeric(community.initial.df[[match(n_species, n_species_types)]][i,])                 x0temp <- 10*x0temp/sum(x0temp)                 CRMtest <- simulateConsumerResource(n_species = n_species,                                                     n_resources = n_resources,                                                     x0 = x0temp, #rep(10, n_species),                                                     resources = rep(100, n_resources),                                                     E = Etest,                                                     # trophic_priority = Priority,                                                     stochastic = TRUE,                                                     t_end = 1000,                                                     t_step = 1,                                                     t_store = 1000)                 CRMspecies <- getCommunity(CRMtest)                 CRMspeciesTotal <- sum(CRMspecies)                 result_df[nrow(result_df)+1,] <- c(n_species, theta, i, n_resources, CRMspeciesTotal)                 result_df2[nrow(result_df2)+1,] <- c(CRMspecies, rep(NA, 13-length(CRMspecies)))                 # makePlotRes(CRMtest$resources)                 # makePlot(CRMtest$matrix)             }         }         rho_mean <- mean(sorensen)         rho_sd <- var(sorensen)         sorensen_df[nrow(sorensen_df)+1, ] <- c(n_species, theta, rho_mean, rho_sd)     } } p_fig2_result_df <- ggplot(result_df, aes(x = n_resources, y = value, group = n_resources)) +     geom_boxplot(outlier.shape = NA) +     geom_jitter(alpha = 0.2, width = 0.2) +     facet_grid(. ~ factor(n_species, levels = n_species_types)) +     theme_bw() +     scale_x_continuous(trans = \"log2\", breaks = n_resources_types) +     xlab(\"number of resources\") +     ylab(\"growth yield (number of individuals)\") p_fig2_result_df"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yagmur Simsek. Maintainer, author. Karoline Faust. Author. Yu Gao. Author. Emma Gheysen. Author. Daniel Rios Garza. Author. Tuomas Borman. Author. Leo Lahti. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"(C) Yu Gao et al. miaSim: R/Bioconductor package easily simulate microbial community dynamics. Methods Ecology Evolution (2023). Version 1.7.7 Package URL: microbiome.github.io/miaSim","code":"@Article{,   title = {miaSim: an R/Bioconductor package to easily simulate microbial community dynamics},   journal = {Methods in Ecology and Evolution},   year = {2023},   doi = {10.1111/2041-210X.14129},   author = {Yu Gao and Yağmur Şimşek and Emma Gheysen and Tuomas Borman and Yi Li and Leo Lahti and Karoline Faust and Daniel Garza},   url = {microbiome.github.io/miaSim},   note = {Version 1.7.7}, }"},{"path":[]},{"path":"/index.html","id":"miasim","dir":"","previous_headings":"","what":"miaSim","title":"Microbiome Data Simulation","text":"miaSim R/Bioconductor package can used simulate (longitudinal) data benchmarking analysis quantitative models microbial communities. installation use, see Getting started page. package based (Tree)SummarizedExperiment data container supports microbiome data analysis. package homepage provides tutorials references implemented models: Self-organised instability (SOI) Hubbell’s neutral model generalized Lotka-Volterra (gLV) Ricker model (discrete gLV) Stochastic logistic model Consumer-resource model","code":""},{"path":"/index.html","id":"miasimshiny","dir":"","previous_headings":"miaSim","what":"miaSimShiny","title":"Microbiome Data Simulation","text":"accompanying miaSimShiny package allows users explore parameter space models real-time intuitive graphical interface. can experiment miaSimShiny online.","code":""},{"path":"/index.html","id":"contributions-and-acknowledgments","dir":"","previous_headings":"miaSim","what":"Contributions and acknowledgments","title":"Microbiome Data Simulation","text":"can find us online Gitter. Contributions welcome issues pull requests development site. follow git flow kind approach. Development version done main branch merged release release. (https://guides.github.com/introduction/flow/) grateful contributors.","code":""},{"path":"/index.html","id":"citing-the-package","dir":"","previous_headings":"miaSim","what":"Citing the package","title":"Microbiome Data Simulation","text":"Kindly cite work follows: Gao et al. (2023). Methods Ecology Evolution. DOI: 10.1111/2041-210X.14129 citation details, see R command citation(\"miaSim\").","code":""},{"path":"/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of conduct","title":"Microbiome Data Simulation","text":"Please note project released Bioconductor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"/reference/dot-applyInterType.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate pairs of interactions according to interaction types — .applyInterType","title":"Generate pairs of interactions according to interaction types — .applyInterType","text":"helper function used combination .getInteractions()","code":""},{"path":"/reference/dot-applyInterType.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate pairs of interactions according to interaction types — .applyInterType","text":"","code":".applyInterType(I, pair, interType)"},{"path":"/reference/dot-applyInterType.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate pairs of interactions according to interaction types — .applyInterType","text":"Matrix: defining interaction pair species pair Numeric: vector length 2, indicating 2 focusing species process applying interaction types interType Character: one 'mutualism', 'commensalism', 'parasitism', 'amensalism', 'competition'. Defining interaction type","code":""},{"path":"/reference/dot-applyInterType.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate pairs of interactions according to interaction types — .applyInterType","text":"matrix interaction types one pair changed","code":""},{"path":"/reference/dot-estimateAFromSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the interspecies interaction matrix A using leave-one-out method — .estimateAFromSimulations","title":"Get the interspecies interaction matrix A using leave-one-out method — .estimateAFromSimulations","text":"generate matrix comparisons simulations one absent species simulation complete species (leave-one-)","code":""},{"path":"/reference/dot-estimateAFromSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the interspecies interaction matrix A using leave-one-out method — .estimateAFromSimulations","text":"","code":".estimateAFromSimulations(   simulations,   simulations2,   n_instances = 1,   t_end = NULL,   scale_off_diagonal = 0.1,   diagonal = -0.5,   connectance = 0.2 )"},{"path":"/reference/dot-estimateAFromSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the interspecies interaction matrix A using leave-one-out method — .estimateAFromSimulations","text":"simulations list simulation(s) complete species simulations2 list simulation(s), one absent species n_instances Integer: number instances generate (default: n_instances = 1) t_end Numeric: end time simulation. identical t_end params_list, overwrite t_end simulation (default: t_end = 1000) scale_off_diagonal Numeric: scale -diagonal elements compared diagonal. parameter function randomA. (default: scale_off_diagonal = 0.1) diagonal Values defining strength self-interactions. Input can number (applied species) vector length n_species. Positive self-interaction values lead exponential growth. parameter function randomA. (default: diagonal = -0.5) connectance Numeric frequency inter-species interactions. .e. proportion non-zero -diagonal terms. interval 0 <= connectance <= 1. parameter function randomA. (default: connectance = 0.2)","code":""},{"path":"/reference/dot-estimateAFromSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the interspecies interaction matrix A using leave-one-out method — .estimateAFromSimulations","text":"matrix dimensions (n_species x n_species) n_species equals number elements simulations2","code":""},{"path":"/reference/dot-eventTimes.html","id":null,"dir":"Reference","previous_headings":"","what":"generate a vector of times when events is happening — .eventTimes","title":"generate a vector of times when events is happening — .eventTimes","text":"generate vector times events happening","code":""},{"path":"/reference/dot-eventTimes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generate a vector of times when events is happening — .eventTimes","text":"","code":".eventTimes(t_events = NULL, t_duration = NULL, t_end = 1000, ...)"},{"path":"/reference/dot-eventTimes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generate a vector of times when events is happening — .eventTimes","text":"t_events, t_duration Numeric: vector starting time duration events t_end Numeric: end time simulation ... : additional parameters pass simulationTimes, including t_start, t_step, t_store.","code":""},{"path":"/reference/dot-eventTimes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generate a vector of times when events is happening — .eventTimes","text":"vector time points simulation","code":""},{"path":"/reference/dot-eventTimes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generate a vector of times when events is happening — .eventTimes","text":"","code":"tEvent <- .eventTimes(     t_events = c(10, 50, 100),     t_duration = c(1, 2, 3),     t_end = 100,     t_store = 100,     t_step = 1 )"},{"path":"/reference/dot-getInteractions.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate interactions according to five types of interactions and their\nweights — .getInteractions","title":"Generate interactions according to five types of interactions and their\nweights — .getInteractions","text":"Generate interactions according five types interactions weights","code":""},{"path":"/reference/dot-getInteractions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate interactions according to five types of interactions and their\nweights — .getInteractions","text":"","code":".getInteractions(n_species, weights, connectance)"},{"path":"/reference/dot-getInteractions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate interactions according to five types of interactions and their\nweights — .getInteractions","text":"n_species Integer: defining dimension matrix interaction weights Numeric: defining weights mutualism, commensalism, parasitism, amensalism, competition interspecies interactions. connectance Numeric: defining density interaction network. Ranging 0 1","code":""},{"path":"/reference/dot-getInteractions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate interactions according to five types of interactions and their\nweights — .getInteractions","text":"matrix interactions interactions changed according weights connectance.","code":""},{"path":"/reference/dot-isPosInt.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether a number is a positive integer — .isPosInt","title":"Check whether a number is a positive integer — .isPosInt","text":"Check whether number positive integer","code":""},{"path":"/reference/dot-isPosInt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether a number is a positive integer — .isPosInt","text":"","code":".isPosInt(x, tol = .Machine$double.eps^0.5)"},{"path":"/reference/dot-isPosInt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether a number is a positive integer — .isPosInt","text":"x Numeric number test tol Numeric tolerance detection","code":""},{"path":"/reference/dot-isPosInt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether a number is a positive integer — .isPosInt","text":"logical value: whether number positive integer.","code":""},{"path":"/reference/dot-rdirichlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate dirichlet random deviates — .rdirichlet","title":"Generate dirichlet random deviates — .rdirichlet","text":"Generate dirichlet random deviates","code":""},{"path":"/reference/dot-rdirichlet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate dirichlet random deviates — .rdirichlet","text":"","code":".rdirichlet(n, alpha)"},{"path":"/reference/dot-rdirichlet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate dirichlet random deviates — .rdirichlet","text":"n Number random vectors generate. alpha Vector containing shape parameters.","code":""},{"path":"/reference/dot-rdirichlet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate dirichlet random deviates — .rdirichlet","text":"vector containing Dirichlet density","code":""},{"path":"/reference/dot-rdirichlet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate dirichlet random deviates — .rdirichlet","text":"","code":"dirichletExample <- .rdirichlet(1, c(1, 2, 3))"},{"path":"/reference/dot-replaceByZero.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace one element with zero in a list — .replaceByZero","title":"Replace one element with zero in a list — .replaceByZero","text":"list contains m elements, lengths element must m, . function intended generate list x0 (initial community) one missing species, prepare parameter simulations_compare estimateAFromSimulations.","code":""},{"path":"/reference/dot-replaceByZero.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace one element with zero in a list — .replaceByZero","text":"","code":".replaceByZero(input_list)"},{"path":"/reference/dot-replaceByZero.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace one element with zero in a list — .replaceByZero","text":"input_list list containing m elements, lengths element must m, .","code":""},{"path":"/reference/dot-replaceByZero.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace one element with zero in a list — .replaceByZero","text":"list dimension input_list, 0 specific positions elements list.","code":""},{"path":"/reference/dot-simulationTimes.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate simulation times and the indices of time points to return\nin simulation functions. — .simulationTimes","title":"Generate simulation times and the indices of time points to return\nin simulation functions. — .simulationTimes","text":"Generate simulation times indices time points return simulation functions.","code":""},{"path":"/reference/dot-simulationTimes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate simulation times and the indices of time points to return\nin simulation functions. — .simulationTimes","text":"","code":".simulationTimes(t_start = 0, t_end = 1000, t_step = 0.1, t_store = 1000)"},{"path":"/reference/dot-simulationTimes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate simulation times and the indices of time points to return\nin simulation functions. — .simulationTimes","text":"t_start Numeric scalar indicating initial time simulation. (default: t_start = 0) t_end Numeric scalar indicating final time simulation (default: t_end = 1000) t_step Numeric scalar indicating interval simulation steps (default: t_step = 0.1) t_store Integer scalar indicating number evenly distributed time points keep (default: t_store = 100)","code":""},{"path":"/reference/dot-simulationTimes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate simulation times and the indices of time points to return\nin simulation functions. — .simulationTimes","text":"lists containing simulation times (t_sys) indices keep.","code":""},{"path":"/reference/dot-simulationTimes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate simulation times and the indices of time points to return\nin simulation functions. — .simulationTimes","text":"","code":"Time <- .simulationTimes(     t_start = 0, t_end = 100, t_step = 0.5,     t_store = 100 ) DefaultTime <- .simulationTimes(t_end = 1000)"},{"path":"/reference/generateSimulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate multiple simulations and store them in a list — generateSimulations","title":"Generate multiple simulations and store them in a list — generateSimulations","text":"function useful generating simulations different parameters simulating multiple instances evaluate stochasticity therein.","code":""},{"path":"/reference/generateSimulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate multiple simulations and store them in a list — generateSimulations","text":"","code":"generateSimulations(   model,   params_list,   param_iter = NULL,   n_instances = 1,   t_end = 1000 )"},{"path":"/reference/generateSimulations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate multiple simulations and store them in a list — generateSimulations","text":"model Character: name model use, must one \"simulateConsumerResource\", \"simulateGLV\", \"simulateHubbellRates\", \"simulateStochasticLogistic\" params_list List: list containing parameters used aforementionned called model param_iter List parameters overwrite different simulations. NULL, simulate different instances using set parameters. (default: param_iter = NULL) n_instances Integer: number instances generate (default: n_instances = 1) t_end Numeric: end time simulation. identical t_end params_list, overwrite t_end simulation (default: t_end = 1000)","code":""},{"path":"/reference/generateSimulations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate multiple simulations and store them in a list — generateSimulations","text":"list containing multiple simulating results","code":""},{"path":"/reference/generateSimulations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate multiple simulations and store them in a list — generateSimulations","text":"","code":"params <- list(     n_species = 10,     n_resources = 5,     E = randomE(         n_species = 10, n_resources = 5,         mean_consumption = 1, mean_production = 3     ),     x0 = rep(0.001, 10),     resources = rep(1000, 5),     monod_constant = matrix(rbeta(10 * 5, 10, 10), nrow = 10, ncol = 5),     inflow_rate = .5,     outflow_rate = .5,     migration_p = 0,     stochastic = TRUE,     t_start = 0,     t_end = 20,     t_store = 100,     growth_rates = runif(10),     norm = FALSE )  # Recommended standard way to generate a set of n simulations (n=2 here) from a given model # simulations <- lapply(seq_len(2), function (i) {do.call(simulateConsumerResource, params)})"},{"path":"/reference/powerlawA.html","id":null,"dir":"Reference","previous_headings":"","what":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","title":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","text":"N Interspecific Interaction matrix values drawn normal distribution H interaction strength heterogeneity drawn power-law distribution parameter alpha, G adjacency matrix -degree reflects heterogeneity powerlaw. scaling factor s may used constrain values interaction matrix within desired range. Diagonal elements defined parameter d.","code":""},{"path":"/reference/powerlawA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","text":"","code":"powerlawA(n_species, alpha = 3, stdev = 1, s = 0.1, d = -1, symmetric = FALSE)"},{"path":"/reference/powerlawA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","text":"n_species integer number species alpha numeric power-law distribution parameter. > 1. (default: alpha = 3.0) Larger values give lower interaction strength heterogeneity, whereas values closer 1 give strong heterogeneity interaction strengths species. words, values alpha close 1 give Strongly Interacting Species (SIS). stdev numeric standard deviation parameter normal distribution mean 0 elements nominal interspecific interaction matrix N drawn. (default: stdev = 1) s numeric scaling parameter final global interaction matrix multiplied. (default: s = 0.1) d numeric diagonal values, indicating self-interactions (use negative values stability). (default: s = 1.0) symmetric logical scalar returning symmetric interaction matrix (default: symmetric=FALSE)","code":""},{"path":"/reference/powerlawA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","text":"interaction matrix dimensions (n_species x n_species)","code":""},{"path":"/reference/powerlawA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","text":"Gibson TE, Bashan , Cao HT, Weiss ST, Liu YY (2016) Origins Control Community Types Human Microbiome. PLOS Computational Biology 12(2): e1004688. https://doi.org/10.1371/journal.pcbi.1004688","code":""},{"path":"/reference/powerlawA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interaction matrix with Power-Law network adjacency matrix — powerlawA","text":"","code":"# Low interaction heterogeneity A_low <- powerlawA(n_species = 10, alpha = 3) # Strong interaction heterogeneity A_strong <- powerlawA(n_species = 10, alpha = 1.01)"},{"path":"/reference/randomA.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random interaction matrix for GLV model — randomA","title":"Generate random interaction matrix for GLV model — randomA","text":"Generates random interaction matrix Generalized Lotka-Volterra (GLV) model.","code":""},{"path":"/reference/randomA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random interaction matrix for GLV model — randomA","text":"","code":"randomA(   n_species,   names_species = NULL,   diagonal = -0.5,   connectance = 0.2,   scale_off_diagonal = 0.1,   mutualism = 1,   commensalism = 1,   parasitism = 1,   amensalism = 1,   competition = 1,   interactions = NULL,   symmetric = FALSE,   list_A = NULL )"},{"path":"/reference/randomA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random interaction matrix for GLV model — randomA","text":"n_species Integer: number species names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) diagonal Values defining strength self-interactions. Input can number (applied species) vector length n_species. Positive self-interaction values lead exponential growth. (default: diagonal = -0.5) connectance Numeric frequency inter-species interactions. .e. proportion non-zero -diagonal terms. interval 0 <= connectance <= 1. (default: connectance = 0.2) scale_off_diagonal Numeric: scale -diagonal elements compared diagonal. (default: scale_off_diagonal = 0.1) mutualism Numeric: relative proportion interactions terms consistent mutualism (positive <-> positive) (default: mutualism = 1) commensalism Numeric: relative proportion interactions terms consistent commensalism (positive <-> neutral) (default: commensalism = 1) parasitism Numeric: relative proportion interactions terms consistent parasitism (positive <-> negative) (default: parasitism = 1) amensalism Numeric: relative proportion interactions terms consistent amensalism (neutral <-> negative) (default: amensalism = 1) competition Numeric: relative proportion interactions terms consistent competition (negative <-> negative) (default: competition = 1) interactions Numeric: values n_species^2 pairwise interaction strengths. Diagonal terms replaced 'diagonal' parameter NULL, interactions drawn runif(n_species^2, min=0, max=abs(diagonal)). Negative values first converted positive signs defined relative weights biological interactions (.e. mutualism, commensalism, parasitism, amensalism, competition) (default: interactions = NULL) symmetric Logical: whether strength mutualistic competitive interactions symmetric. implemented overwrite half matrix, proportions interactions might deviate expectations. (default: symmetric=FALSE) list_A List: list matrices generated randomA. Used support different groups interactions. NULL (default), group considered. Otherwise given list matrices overwrite values around diagonal. (default: list_A = NULL)","code":""},{"path":"/reference/randomA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random interaction matrix for GLV model — randomA","text":"randomA returns matrix dimensions (n_species x n_species)","code":""},{"path":"/reference/randomA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random interaction matrix for GLV model — randomA","text":"","code":"dense_A <- randomA(     n_species = 10,     scale_off_diagonal = 1,     diagonal = -1.0,     connectance = 0.9 )  sparse_A <- randomA(     n_species = 10,     diagonal = -1.0,     connectance = 0.09 )  user_interactions <- rbeta(n = 10^2, .5, .5) user_A <- randomA(n_species = 10, interactions = user_interactions)  competitive_A <- randomA(     n_species = 10,     mutualism = 0,     commensalism = 0,     parasitism = 0,     amensalism = 0,     competition = 1,     connectance = 1,     scale_off_diagonal = 1 )  parasitism_A <- randomA(     n_species = 10,     mutualism = 0,     commensalism = 0,     parasitism = 1,     amensalism = 0,     competition = 0,     connectance = 1,     scale_off_diagonal = 1,     symmetric = TRUE )  list_A <- list(dense_A, sparse_A, competitive_A, parasitism_A) groupA <- randomA(n_species = 40, list_A = list_A)"},{"path":"/reference/randomE.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate random efficiency matrix — randomE","title":"Generate random efficiency matrix — randomE","text":"Generate random efficiency matrix consumer resource model Dirichlet distribution, positive efficiencies indicate consumption resources, whilst negatives indicate species produce resource.","code":""},{"path":"/reference/randomE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate random efficiency matrix — randomE","text":"","code":"randomE(   n_species,   n_resources,   names_species = NULL,   names_resources = NULL,   mean_consumption = n_resources/4,   mean_production = n_resources/6,   maintenance = 0.5,   trophic_levels = NULL,   trophic_preferences = NULL,   exact = FALSE )"},{"path":"/reference/randomE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate random efficiency matrix — randomE","text":"n_species Integer: number species n_resources Integer: number resources names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) names_resources Character: names resources. NULL, paste0(\"res\", seq_len(n_resources)) used. mean_consumption Numeric: mean number resources consumed species drawn poisson distribution (default: mean_consumption = n_resources/4) mean_production Numeric: mean number resources produced species drawn poisson distribution (default: mean_production = n_resources/6) maintenance Numeric: proportion resources converted products 0~1 proportion resources used maintain living microorganisms. 0 means resources used reproduction microorganisms, 1 means resources used maintain living organisms resources left growth(reproduction). (default: maintenance = 0.5) trophic_levels Integer: number species microbial trophic levels. NULL, default, microbial trophic levels considered. (default: trophic_levels = NULL) trophic_preferences List: preferred resources productions trophic level. Positive values indicate consumption resources, whilst negatives indicate species produce resource. exact Logical: whether set number consumption/production exact mean_consumption/mean_production set using Poisson distribution. (default: exact = FALSE) length(trophic_preferences) smaller length(trophic_levels), NULL values appended lower trophic levels. NULL, default, consumption preference defined randomly. (default: trophic_preferences = NULL)","code":""},{"path":"/reference/randomE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate random efficiency matrix — randomE","text":"randomE returns matrix E dimensions (n_species x n_resources), row represents species.","code":""},{"path":"/reference/randomE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate random efficiency matrix — randomE","text":"","code":"# example with minimum parameters ExampleEfficiencyMatrix <- randomE(n_species = 5, n_resources = 12)  # examples with specific parameters ExampleEfficiencyMatrix <- randomE(     n_species = 3, n_resources = 6,     names_species = letters[1:3],     names_resources = paste0(\"res\", LETTERS[1:6]),     mean_consumption = 3, mean_production = 1 ) ExampleEfficiencyMatrix <- randomE(     n_species = 3, n_resources = 6,     maintenance = 0.4 ) ExampleEfficiencyMatrix <- randomE(     n_species = 3, n_resources = 6,     mean_consumption = 3, mean_production = 1, maintenance = 0.4 )  # examples with microbial trophic levels ExampleEfficiencyMatrix <- randomE(     n_species = 10, n_resources = 15,     trophic_levels = c(6, 3, 1),     trophic_preferences = list(         c(rep(1, 5), rep(-1, 5), rep(0, 5)),         c(rep(0, 5), rep(1, 5), rep(-1, 5)),         c(rep(0, 10), rep(1, 5))     ) ) ExampleEfficiencyMatrix <- randomE(     n_species = 10, n_resources = 15,     trophic_levels = c(6, 3, 1),     trophic_preferences = list(c(rep(1, 5), rep(-1, 5), rep(0, 5)), NULL, NULL) ) ExampleEfficiencyMatrix <- randomE(     n_species = 10, n_resources = 15,     trophic_levels = c(6, 3, 1) )"},{"path":"/reference/rdirichlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate dirichlet random deviates — rdirichlet","title":"Generate dirichlet random deviates — rdirichlet","text":"Generate dirichlet random deviates","code":""},{"path":"/reference/rdirichlet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate dirichlet random deviates — rdirichlet","text":"","code":"rdirichlet(n, alpha)"},{"path":"/reference/rdirichlet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate dirichlet random deviates — rdirichlet","text":"n Number random vectors generate. alpha Vector containing shape parameters.","code":""},{"path":"/reference/rdirichlet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate dirichlet random deviates — rdirichlet","text":"vector containing Dirichlet density","code":""},{"path":"/reference/rdirichlet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate dirichlet random deviates — rdirichlet","text":"","code":"dirichletExample <- rdirichlet(1, c(1, 2, 3))"},{"path":"/reference/simulateConsumerResource.html","id":null,"dir":"Reference","previous_headings":"","what":"Consumer-resource model simulation — simulateConsumerResource","title":"Consumer-resource model simulation — simulateConsumerResource","text":"Simulates time series consumer-resource model.","code":""},{"path":"/reference/simulateConsumerResource.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Consumer-resource model simulation — simulateConsumerResource","text":"","code":"simulateConsumerResource(   n_species,   n_resources,   names_species = NULL,   names_resources = NULL,   E = NULL,   x0 = NULL,   resources = NULL,   resources_dilution = NULL,   growth_rates = NULL,   monod_constant = NULL,   sigma_drift = 0.001,   sigma_epoch = 0.1,   sigma_external = 0.3,   sigma_migration = 0.01,   epoch_p = 0.001,   t_external_events = NULL,   t_external_durations = NULL,   stochastic = FALSE,   migration_p = 0.01,   metacommunity_probability = NULL,   error_variance = 0,   norm = FALSE,   t_end = 1000,   trophic_priority = NULL,   inflow_rate = 0,   outflow_rate = 0,   volume = 1000,   ... )"},{"path":"/reference/simulateConsumerResource.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Consumer-resource model simulation — simulateConsumerResource","text":"n_species Integer: number species n_resources Integer: number resources names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) names_resources Character: names resources. NULL, paste0(\"res\", seq_len(n_resources)) used. E matrix: matrix efficiency. matrix defining efficiency resource--biomass conversion (positive values) relative conversion metabolic -products (negative values). NULL, randomE(n_species, n_resources) used. (default: E = NULL) x0 Numeric: initial abundances simulated species. NULL, runif(n = n_species, min = 0.1, max = 10) used. (default: x0 = NULL) resources Numeric: initial concentrations resources. NULL, runif(n = n_resources, min = 1, max = 100) used. (default: resources = NULL) resources_dilution Numeric: concentrations resources continuous inflow (applicable inflow_rate > 0). NULL, resources used. (default: resources_dilution = NULL) growth_rates Numeric: vector maximum growth rates(mu) species. NULL, rep(1, n_species) used. (default: growth_rates = NULL) monod_constant matrix: constant additive monod growth n_species consuming n_resources. NULL, matrix(rgamma(n = n_species*n_resources, shape = 50*max(resources), rate = 1), nrow = n_species) used. (default: monod_constant = NULL) sigma_drift Numeric: standard deviation normally distributed noise applied time step (t_step) (default: sigma_drift = 0.001) sigma_epoch Numeric: standard deviation normally distributed noise applied random periods community composition frequency defined epoch_p parameter (default: sigma_epoch = 0.1) sigma_external Numeric: standard deviation normally distributed noise applied user-defined external events/disturbances (default: sigma_external = 0.3) sigma_migration Numeric: standard deviation normally distributed variable defines intensity migration time step (t_step) (default: sigma_migration = 0.01) epoch_p Numeric: probability/frequency random periodic changes introduced community composition (default: epoch_p = 0.001) t_external_events Numeric: starting time points defined external events introduce random changes community composition (default: t_external_events = NULL) t_external_durations Numeric: respective duration external events defined 't_external_events' (times) sigma_external (std). (default: t_external_durations = NULL) stochastic Logical: whether introduce noise simulation. False, sigma_drift, sigma_epoch, sigma_external ignored. (default: stochastic = FALSE) migration_p Numeric: probability/frequency migration metacommunity. (default: migration_p = 0.01) metacommunity_probability Numeric: Normalized probability distribution likelihood species metacommunity can enter community simulation. NULL, rdirichlet(1, alpha = rep(1,n_species)) used. (default: metacommunity_probability = NULL) error_variance Numeric: variance measurement error. default equals 0, indicating result contain measurement error. value non-negative. (default: error_variance = 0) norm Logical: whether time series returned abundances proportions (norm = TRUE) raw counts (default: norm = FALSE) (default: norm = FALSE) t_end Numeric: end time simulationTimes, defining modeled time length community. (default: t_end = 1000) trophic_priority Matrix: matrix defining orders resources consumed species. NULL, default, feature turned , species consume resources simultaneously grow. dimension identical matrix E. (default: trophic_priority = NULL) inflow_rate, outflow_rate Numeric: inflow outflow rate culture process. default, inflow_rate outflow_rate 0, indicating batch culture process. setting equally larger 0, can simulate continuous culture(e.g. chemostat). volume Numeric: volume continuous cultivation. parameter important simulations inflow_rate outflow_rate 0. (default: volume = 1000) ... additional parameters, see utils know .","code":""},{"path":"/reference/simulateConsumerResource.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Consumer-resource model simulation — simulateConsumerResource","text":"TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateConsumerResource.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Consumer-resource model simulation — simulateConsumerResource","text":"","code":"n_species <- 2 n_resources <- 4 tse <- simulateConsumerResource(     n_species = n_species,     n_resources = n_resources )  if (FALSE) { # example with user-defined values (names_species, names_resources, E, x0, # resources, growth_rates, error_variance, t_end, t_step)  ExampleE <- randomE(     n_species = n_species, n_resources = n_resources,     mean_consumption = 3, mean_production = 1, maintenance = 0.4 ) ExampleResources <- rep(100, n_resources) tse1 <- simulateConsumerResource(     n_species = n_species,     n_resources = n_resources, names_species = letters[seq_len(n_species)],     names_resources = paste0(\"res\", LETTERS[seq_len(n_resources)]), E = ExampleE,     x0 = rep(0.001, n_species), resources = ExampleResources,     growth_rates = runif(n_species),     error_variance = 0.01,     t_end = 5000,     t_step = 1 )  # example with trophic levels n_species <- 10 n_resources <- 15 ExampleEfficiencyMatrix <- randomE(     n_species = 10, n_resources = 15,     trophic_levels = c(6, 3, 1),     trophic_preferences = list(         c(rep(1, 5), rep(-1, 5), rep(0, 5)),         c(rep(0, 5), rep(1, 5), rep(-1, 5)),         c(rep(0, 10), rep(1, 5))     ) )  ExampleResources <- c(rep(500, 5), rep(200, 5), rep(50, 5)) tse2 <- simulateConsumerResource(     n_species = n_species,     n_resources = n_resources,     names_species = letters[1:n_species],     names_resources = paste0(         \"res\", LETTERS[1:n_resources]     ),     E = ExampleEfficiencyMatrix,     x0 = rep(0.001, n_species),     resources = ExampleResources,     growth_rates = rep(1, n_species),     # error_variance = 0.001,     t_end = 5000, t_step = 1 )  # example with trophic priority n_species <- 4 n_resources <- 6 ExampleE <- randomE(     n_species = n_species,     n_resources = n_resources,     mean_consumption = n_resources,     mean_production = 0 ) ExampleTrophicPriority <- t(apply(     matrix(sample(n_species * n_resources),         nrow = n_species     ),     1, order )) # make sure that for non-consumables resources for each species, # the priority is 0 (smaller than any given priority) ExampleTrophicPriority <- (ExampleE > 0) * ExampleTrophicPriority tse3 <- simulateConsumerResource(     n_species = n_species,     n_resources = n_resources,     E = ExampleE,     trophic_priority = ExampleTrophicPriority,     t_end = 2000 ) }"},{"path":"/reference/simulateEventTimes.html","id":null,"dir":"Reference","previous_headings":"","what":"generate a vector of times when events is happening — simulateEventTimes","title":"generate a vector of times when events is happening — simulateEventTimes","text":"generate vector times events happening","code":""},{"path":"/reference/simulateEventTimes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generate a vector of times when events is happening — simulateEventTimes","text":"","code":"simulateEventTimes(t_events = NULL, t_duration = NULL, t_end = 1000, ...)"},{"path":"/reference/simulateEventTimes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generate a vector of times when events is happening — simulateEventTimes","text":"t_events, t_duration Numeric: vector starting time duration events t_end Numeric: end time simulation ... : additional parameters pass simulationTimes, including t_start, t_step, t_store.","code":""},{"path":"/reference/simulateEventTimes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generate a vector of times when events is happening — simulateEventTimes","text":"vector time points simulation","code":""},{"path":"/reference/simulateEventTimes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generate a vector of times when events is happening — simulateEventTimes","text":"","code":"tEvent <- simulateEventTimes(     t_events = c(10, 50, 100),     t_duration = c(1, 2, 3),     t_end = 100,     t_store = 100,     t_step = 1 )"},{"path":"/reference/simulateGLV.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","title":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","text":"Simulates time series generalized Lotka-Volterra model.","code":""},{"path":"/reference/simulateGLV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","text":"","code":"simulateGLV(   n_species,   names_species = NULL,   A = NULL,   x0 = NULL,   growth_rates = NULL,   sigma_drift = 0.001,   sigma_epoch = 0.1,   sigma_external = 0.3,   sigma_migration = 0.01,   epoch_p = 0.001,   t_external_events = NULL,   t_external_durations = NULL,   stochastic = TRUE,   migration_p = 0.01,   metacommunity_probability = NULL,   error_variance = 0,   norm = FALSE,   t_end = 1000,   ... )"},{"path":"/reference/simulateGLV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","text":"n_species Integer: number species names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) matrix: interaction matrix defining positive negative interactions n_species. NULL, randomA(n_species) used. (default: = NULL) x0 Numeric: initial abundances simulated species. NULL, runif(n = n_species, min = 0, max = 1) used. (default: x0 = NULL) growth_rates Numeric: growth rates simulated species. NULL, runif(n = n_species, min = 0, max = 1) used. (default: growth_rates = NULL) sigma_drift Numeric: standard deviation normally distributed noise applied time step (t_step) (default: sigma_drift = 0.001) sigma_epoch Numeric: standard deviation normally distributed noise applied random periods community composition frequency defined epoch_p parameter (default: sigma_epoch = 0.1) sigma_external Numeric: standard deviation normally distributed noise applied user-defined external events/disturbances (default: sigma_external = 0.3) sigma_migration Numeric: standard deviation normally distributed variable defines intensity migration time step (t_step) (default: sigma_migration = 0.01) epoch_p Numeric: probability/frequency random periodic changes introduced community composition (default: epoch_p = 0.001) t_external_events Numeric: starting time points defined external events introduce random changes community composition (default: t_external_events = NULL) t_external_durations Numeric: respective duration external events defined 't_external_events' (times) sigma_external (std). (default: t_external_durations = NULL) stochastic Logical: whether introduce noise simulation. False, sigma_drift, sigma_epoch, sigma_external ignored. (default: stochastic = FALSE) migration_p Numeric: probability/frequency migration metacommunity. (default: migration_p = 0.01) metacommunity_probability Numeric: Normalized probability distribution likelihood species metacommunity can enter community simulation. NULL, rdirichlet(1, alpha = rep(1,n_species)) used. (default: metacommunity_probability = NULL) error_variance Numeric: variance measurement error. default equals 0, indicating result contain measurement error. value non-negative. (default: error_variance = 0) norm Logical: whether time series returned abundances proportions (norm = TRUE) raw counts (default: norm = FALSE) (default: norm = FALSE) t_end Numeric: end time simulationTimes, defining modeled time length community. (default: t_end = 1000) ... additional parameters, see utils know .","code":""},{"path":"/reference/simulateGLV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","text":"simulateGLV returns TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateGLV.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","text":"Simulates community time series using generalized Lotka-Volterra model, defined dx/dt = x(b+Ax), x vector species abundances, diag(x) diagonal matrix diagonal values set x. interaction matrix b vector growth rates.","code":""},{"path":"/reference/simulateGLV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Lotka-Volterra (gLV) simulation — simulateGLV","text":"","code":"# generate a random interaction matrix ExampleA <- randomA(n_species = 4, diagonal = -1)  # run the model with default values (only stochastic migration considered) tse <- simulateGLV(n_species = 4, A = ExampleA)  # run the model with two external disturbances at time points 240 and 480 # with durations equal to 1 (10 time steps when t_step by default is 0.1). ExampleGLV <- simulateGLV(     n_species = 4, A = ExampleA,     t_external_events = c(0, 240, 480), t_external_durations = c(0, 1, 1) )  # run the model with no perturbation nor migration set.seed(42) tse1 <- simulateGLV(     n_species = 4, A = ExampleA, stochastic = FALSE,     sigma_migration = 0 )  # run the model with no perturbation nor migration but with measurement error set.seed(42) tse2 <- simulateGLV(     n_species = 4, A = ExampleA, stochastic = FALSE,     error_variance = 0.001, sigma_migration = 0 )"},{"path":"/reference/simulateHubbell.html","id":null,"dir":"Reference","previous_headings":"","what":"Hubbell's neutral model simulation — simulateHubbell","title":"Hubbell's neutral model simulation — simulateHubbell","text":"Neutral species abundances simulation according Hubbell model.","code":""},{"path":"/reference/simulateHubbell.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hubbell's neutral model simulation — simulateHubbell","text":"","code":"simulateHubbell(   n_species,   M,   carrying_capacity = 1000,   k_events = 10,   migration_p = 0.02,   t_skip = 0,   t_end,   norm = FALSE )"},{"path":"/reference/simulateHubbell.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hubbell's neutral model simulation — simulateHubbell","text":"n_species integer amount different species initially local community M integer amount different species metacommunity, including local community carrying_capacity integer value fixed amount individuals local community (default: carrying_capacity = 1000) k_events integer value fixed amount deaths local community individuals generation (default: k_events = 10) migration_p numeric immigration rate: probability death local community replaced migrant metacommunity rather birth local community member (default: migration_p = 0.02) t_skip integer number generations included outputted species abundance matrix. (default: t_skip = 0) t_end integer number simulations simulated norm logical scalar choosing whether time series returned abundances proportions (norm = TRUE) raw counts (default: norm = FALSE)","code":""},{"path":"/reference/simulateHubbell.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hubbell's neutral model simulation — simulateHubbell","text":"simulateHubbell returns TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateHubbell.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hubbell's neutral model simulation — simulateHubbell","text":"Rosindell, James et al. \"unified neutral theory biodiversity biogeography age ten.\" Trends ecology & evolution vol. 26,7 (2011).","code":""},{"path":"/reference/simulateHubbell.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hubbell's neutral model simulation — simulateHubbell","text":"","code":"tse <- simulateHubbell(     n_species = 8, M = 10, carrying_capacity = 1000, k_events = 50,     migration_p = 0.02, t_end = 100 )"},{"path":"/reference/simulateHubbellRates.html","id":null,"dir":"Reference","previous_headings":"","what":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","title":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","text":"Neutral species abundances simulation according Hubbell model. model shows losses society can replaced either birth individuals immigration depending probabilities. specific time events birth migration calculated time effect considered determine next event.","code":""},{"path":"/reference/simulateHubbellRates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","text":"","code":"simulateHubbellRates(   n_species = NULL,   x0 = NULL,   names_species = NULL,   migration_p = 0.01,   metacommunity_probability = NULL,   k_events = 1,   growth_rates = NULL,   error_variance = 0,   norm = FALSE,   t_end = 1000,   ... )"},{"path":"/reference/simulateHubbellRates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","text":"n_species Integer: number species x0 Numeric: initial species composition. NULL, rep(100, n_species) used. names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) migration_p Numeric: probability/frequency migration metacommunity. (default: migration_p = 0.01) metacommunity_probability Numeric: Normalized probability distribution likelihood species metacommunity can enter community simulation. NULL, rdirichlet(1, alpha = rep(1,n_species)) used. (default: metacommunity_probability = NULL) k_events Integer: number events simulate updating sampling distributions. (default: k_events = 1) growth_rates Numeric: maximum growth rates(mu) species. NULL, rep(1, n_species) used. (default: growth_rates = NULL) error_variance Numeric: variance measurement error. default equals 0, indicating result contain measurement error. value non-negative. (default: error_variance = 0) norm Logical: whether time series returned abundances proportions (norm = TRUE) raw counts (default: norm = FALSE) (default: norm = FALSE) t_end Numeric: end time simulationTimes, defining modeled time length community. (default: t_end = 1000) ... additional parameters, see utils know .","code":""},{"path":"/reference/simulateHubbellRates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","text":"simulateHubbellRates returns TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateHubbellRates.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","text":"Rosindell, James et al. \"unified neutral theory biodiversity biogeography age ten.\" Trends ecology & evolution vol. 26,7 (2011).","code":""},{"path":"/reference/simulateHubbellRates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hubbell's neutral model simulation applied to time series — simulateHubbellRates","text":"","code":"set.seed(42) tse <- simulateHubbellRates(n_species = 5)  miaViz::plotSeries(tse, x = \"time\") #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to max; returning -Inf #> Warning: no non-missing arguments to max; returning -Inf   # no migration, all stochastic birth and death set.seed(42) tse1 <- simulateHubbellRates(n_species = 5, migration_p = 0)  # all migration, no stochastic birth and death set.seed(42) tse2 <- simulateHubbellRates(     n_species = 5,     migration_p = 1,     metacommunity_probability = c(0.1, 0.15, 0.2, 0.25, 0.3),     t_end = 20,     t_store = 200 )  # all migration, no stochastic birth and death, but with measurement errors set.seed(42) tse3 <- simulateHubbellRates(     n_species = 5,     migration_p = 1,     metacommunity_probability = c(0.1, 0.15, 0.2, 0.25, 0.3),     t_end = 20,     t_store = 200,     error_variance = 100 )  # model with specified inputs set.seed(42) tse4 <- simulateHubbellRates(     n_species = 5,     migration_p = 0.1,     metacommunity_probability = c(0.1, 0.15, 0.2, 0.25, 0.3),     t_end = 200,     t_store = 1000,     k_events = 5,     growth_rates = c(1.1, 1.05, 1, 0.95, 0.9) )"},{"path":"/reference/simulateRicker.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate time series with the Ricker model — simulateRicker","title":"Generate time series with the Ricker model — simulateRicker","text":"Ricker model discrete version generalized Lotka-Volterra model implemented proposed Fisher Mehta PLoS ONE 2014.","code":""},{"path":"/reference/simulateRicker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate time series with the Ricker model — simulateRicker","text":"","code":"simulateRicker(   n_species,   A,   names_species = NULL,   x0 = runif(n_species),   carrying_capacities = runif(n_species),   error_variance = 0.05,   explosion_bound = 10^8,   t_end = 1000,   norm = FALSE,   ... )"},{"path":"/reference/simulateRicker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate time series with the Ricker model — simulateRicker","text":"n_species Integer: number species interaction matrix names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) x0 Numeric: initial abundances simulated species. NULL, runif(n = n_species, min = 0, max = 1) used. carrying_capacities numeric carrying capacities. NULL, runif(n = n_species, min = 0, max = 1) used. error_variance Numeric: variance measurement error. default equals 0, indicating result contain measurement error. value non-negative. (default: error_variance = 0.05) explosion_bound numeric value boundary explosion (default: explosion_bound = 10^8) t_end integer number simulations simulated norm logical scalar returning normalised abundances (proportions generation) (default: norm = FALSE) ... additional parameters, see utils know .","code":""},{"path":"/reference/simulateRicker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate time series with the Ricker model — simulateRicker","text":"simulateRicker returns TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateRicker.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate time series with the Ricker model — simulateRicker","text":"Fisher & Mehta (2014). Identifying Keystone Species Human Gut Microbiome Metagenomic Timeseries using Sparse Linear Regression. PLoS One 9:e102451","code":""},{"path":"/reference/simulateRicker.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate time series with the Ricker model — simulateRicker","text":"","code":"A <- powerlawA(10, alpha = 1.01) tse <- simulateRicker(n_species = 10, A, t_end = 100)"},{"path":"/reference/simulateSOI.html","id":null,"dir":"Reference","previous_headings":"","what":"Self-Organised Instability model (SOI) simulation — simulateSOI","title":"Self-Organised Instability model (SOI) simulation — simulateSOI","text":"Generate time-series Self-Organised Instability (SOI) model. Implements K-leap method accelerating stochastic simulation.","code":""},{"path":"/reference/simulateSOI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Self-Organised Instability model (SOI) simulation — simulateSOI","text":"","code":"simulateSOI(   n_species,   x0 = NULL,   names_species = NULL,   carrying_capacity = 1000,   A = NULL,   k_events = 5,   t_end = 1000,   metacommunity_probability = runif(n_species, min = 0.1, max = 0.8),   death_rates = runif(n_species, min = 0.01, max = 0.08),   norm = FALSE )"},{"path":"/reference/simulateSOI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Self-Organised Instability model (SOI) simulation — simulateSOI","text":"n_species Integer: number species x0 vector initial community abundances (default: x0 = NULL), based migration rates names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) carrying_capacity integer community size, number available sites (individuals) matrix: interaction matrix defining positive negative interactions n_species. NULL, powerlawA(n_species) used. (default: = NULL) k_events integer number transition events allowed take place one leap. (default: k_events = 5). Higher values reduce runtime, also accuracy simulation. t_end Numeric: end time simulation, defining modeled time length community. (default: t_end = 1000) metacommunity_probability Numeric: Normalized probability distribution likelihood species metacommunity can enter community simulation. default, runif(n_species, min = 0.1, max = 0.8) used. (default: metacommunity_probability = runif(n_species, min = 0.1, max = 0.8)) death_rates Numeric: death rates species. default, runif(n_species, min = 0.01, max = 0.08) used. (default: death_rates = runif(n_species, min = 0.01, max = 0.08)) norm logical scalar indicating whether time series returned abundances proportions (norm = TRUE) raw counts (default: norm = FALSE)","code":""},{"path":"/reference/simulateSOI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Self-Organised Instability model (SOI) simulation — simulateSOI","text":"simulateSOI returns TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateSOI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Self-Organised Instability model (SOI) simulation — simulateSOI","text":"","code":"# Generate interaction matrix A <- miaSim::powerlawA(10, alpha = 1.2) # Simulate data from the SOI model tse <- simulateSOI(     n_species = 10, carrying_capacity = 1000, A = A,     k_events = 5, x0 = NULL, t_end = 150, norm = TRUE )"},{"path":"/reference/simulateStochasticLogistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Logistic simulation — simulateStochasticLogistic","title":"Stochastic Logistic simulation — simulateStochasticLogistic","text":"Simulates time series (stochastic) logistic model","code":""},{"path":"/reference/simulateStochasticLogistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Logistic simulation — simulateStochasticLogistic","text":"","code":"simulateStochasticLogistic(   n_species,   names_species = NULL,   growth_rates = NULL,   carrying_capacities = NULL,   death_rates = NULL,   x0 = NULL,   sigma_drift = 0.001,   sigma_epoch = 0.1,   sigma_external = 0.3,   sigma_migration = 0.01,   epoch_p = 0.001,   t_external_events = NULL,   t_external_durations = NULL,   migration_p = 0.01,   metacommunity_probability = NULL,   stochastic = TRUE,   error_variance = 0,   norm = FALSE,   t_end = 1000,   ... )"},{"path":"/reference/simulateStochasticLogistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Logistic simulation — simulateStochasticLogistic","text":"n_species Integer: number species names_species Character: names species. NULL, paste0(\"sp\", seq_len(n_species)) used. (default: names_species = NULL) growth_rates Numeric: growth rates simulated species. NULL, runif(n = n_species, min = 0.1, max = 0.2) used. (default: growth_rates = NULL) carrying_capacities Numeric: max population species supported community. NULL, runif(n = n_species, min = 1000, max = 2000) used. (default: carrying_capacities = NULL) death_rates Numeric: death rates species. NULL, runif(n = n_species, min = 0.0005, max = 0.0025) used. (default: death_rates = NULL) x0 Numeric: initial abundances simulated species. NULL, runif(n = n_species, min = 0.1, max = 10) used. (default: x0 = NULL) sigma_drift Numeric: standard deviation normally distributed noise applied time step (t_step) (default: sigma_drift = 0.001) sigma_epoch Numeric: standard deviation normally distributed noise applied random periods community composition frequency defined epoch_p parameter (default: sigma_epoch = 0.1) sigma_external Numeric: standard deviation normally distributed noise applied user-defined external events/disturbances (default: sigma_external = 0.3) sigma_migration Numeric: standard deviation normally distributed variable defines intensity migration time step (t_step) (default: sigma_migration = 0.01) epoch_p Numeric: probability/frequency random periodic changes introduced community composition (default: epoch_p = 0.001) t_external_events Numeric: starting time points defined external events introduce random changes community composition (default: t_external_events = NULL) t_external_durations Numeric: respective duration external events defined 't_external_events' (times) sigma_external (std). (default: t_external_durations = NULL) migration_p Numeric: probability/frequency migration metacommunity. (default: migration_p = 0.01) metacommunity_probability Numeric: Normalized probability distribution likelihood species metacommunity can enter community simulation. NULL, rdirichlet(1, alpha = rep(1,n_species)) used. (default: metacommunity_probability = NULL) stochastic Logical: whether introduce noise simulation. False, sigma_drift, sigma_epoch, sigma_external ignored. (default: stochastic = TRUE) error_variance Numeric: variance measurement error. default equals 0, indicating result contain measurement error. value non-negative. (default: error_variance = 0) norm Logical: whether time series returned abundances proportions (norm = TRUE) raw counts (default: norm = FALSE) (default: norm = FALSE) t_end Numeric: end time simulationTimes, defining modeled time length community. (default: t_end = 1000) ... additional parameters, see utils know .","code":""},{"path":"/reference/simulateStochasticLogistic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stochastic Logistic simulation — simulateStochasticLogistic","text":"simulateStochasticLogistic returns TreeSummarizedExperiment class object","code":""},{"path":"/reference/simulateStochasticLogistic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stochastic Logistic simulation — simulateStochasticLogistic","text":"change rate species defined dx/dt = b*x*(1-(x/k))*rN - dr*x, b vector growth rates, x vector initial species abundances, k vector maximum carrying capacities, rN random number ranged 0 1 changes time step, dr vector constant death rates. Also, vectors initial dead species abundances can set. number species set 0 dead species abundances surpass alive species abundances.","code":""},{"path":"/reference/simulateStochasticLogistic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stochastic Logistic simulation — simulateStochasticLogistic","text":"","code":"# Example of logistic model without stochasticity, death rates, or external # disturbances set.seed(42) tse <- simulateStochasticLogistic(     n_species = 5,     stochastic = FALSE, death_rates = rep(0, 5) )  # Adding a death rate set.seed(42) tse1 <- simulateStochasticLogistic(     n_species = 5,     stochastic = FALSE, death_rates = rep(0.01, 5) )  # Example of stochastic logistic model with measurement error set.seed(42) tse2 <- simulateStochasticLogistic(     n_species = 5,     error_variance = 1000 )  # example with all the initial parameters defined by the user set.seed(42) tse3 <- simulateStochasticLogistic(     n_species = 2,     names_species = c(\"species1\", \"species2\"),     growth_rates = c(0.2, 0.1),     carrying_capacities = c(1000, 2000),     death_rates = c(0.001, 0.0015),     x0 = c(3, 0.1),     sigma_drift = 0.001,     sigma_epoch = 0.3,     sigma_external = 0.5,     sigma_migration = 0.002,     epoch_p = 0.001,     t_external_events = c(100, 200, 300),     t_external_durations = c(0.1, 0.2, 0.3),     migration_p = 0.01,     metacommunity_probability = miaSim::rdirichlet(1, alpha = rep(1, 2)),     stochastic = TRUE,     error_variance = 0,     norm = FALSE, # TRUE,     t_end = 400,     t_start = 0, t_step = 0.01,     t_store = 1500 )"}]
