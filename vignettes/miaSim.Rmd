---
title: "miaSim: Microbiome Data Simulation"
author:
- name: Yagmur Simsek
  email: yagmur.simsek@fu-berlin.de
- name: Yu Gao
  email: gaoyu19920914@gmail.com
- name: Emma Gheysen
  email: emma.gheysen@student.kuleuven.be
- name: Daniel Rios Garza
  email: danielrios.garza@kuleuven.be
- name: Karoline Faust
  email: karoline.faust@kuleuven.be  
- name: Leo Lahti
  email: leo.lahti@iki.fi  
date: "`r Sys.Date()`"
package: miaSim
output: 
    BiocStyle::html_document:
        fig_height: 7
        fig_width: 10
        toc: yes
        toc_depth: 2
        number_sections: true
vignette: >
    %\VignetteIndexEntry{miaSim}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
    \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE}
knitr::opts_chunk$set(cache = FALSE,
                        fig.width = 9,
                        message = FALSE,
                        warning = FALSE)
```

# Introduction

`miaSim` implements tools for microbiome data simulation based on different ecological modeling assumptions. These can be used to simulate species abundance matrices, including time series. For a detailed function documentation, see the [function reference page](https://microbiome.github.io/miaSim/reference/index.html)

Install the Bioconductor release version with

```{r install-bioc, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
```

Load the library

```{r load, eval=TRUE}
library(miaSim)
```

## Examples

### Generating species interaction matrices

Some of the models rely on interaction matrices that represents interaction
heterogeneity between species. The interaction matrix can be generated with
different distributional assumptions.

Generate interactions from normal distribution:

```{r}
A_normal <- powerlawA(n_species = 4, alpha = 3)
```

Generate interactions from uniform distribution:

```{r}
A_uniform <- randomA(n_species = 10, diagonal = -0.4, connectance = 0.5, interactions = runif(n = 10^2, min = -0.8, max = 0.8))
```

### Generalized Lotka-Volterra (gLV)

The generalized Lotka-Volterra simulation model generates time-series assuming
microbial population dynamics and interaction.

```{r glv}
glvmodel <- simulateGLV(n_species = 4, A = A_normal, t_start = 0, 
    t_store = 1000, stochastic = FALSE, norm = FALSE)

```

### Ricker model

Ricker model is a discrete version of the gLV:

```{r ricker}
rickermodel <- simulateRicker(n_species=4, A = A_normal, t_end=100, norm = FALSE)
```

The number of species specified in the interaction matrix must be the same as the species used in the models.

### Hubbell model

Hubbell Neutral simulation model characterizes diversity and relative abundance of species in ecological communities assuming migration, births and deaths but no interactions. Losses become replaced by migration or birth.

```{r}
hubbellmodel <- simulateHubbell(n_species = 8, M = 10, carrying_capacity = 1000,
                                k_events = 50, migration_p = 0.02, t_end = 100)
```

One can also simulate parameters for the Hubbell model.

```{r}
hubbellmodelRates <- simulateHubbellRates(x0 = c(0,5,10),
    migration_p = 0.1, metacommunity_probability = NULL, k_events = 1, 
    growth_rates = NULL, norm = FALSE, t_end=1000)
```

### Self-Organised Instability (SOI)

The Self-Organised Instability (SOI) model generates time series for communities and accelerates stochastic simulation.

```{r}
soimodel <- simulateSOI(n_species = 4, carrying_capacity = 1000, A = A_normal, k_events=5, x0 = NULL,t_end = 150, norm = TRUE)
```

### Stochastic logistic model

Stochastic logistic model is used to determine dead and alive counts in community.

```{r}
logisticmodel <- simulateStochasticLogistic(n_species = 5)
```

### Consumer-resource model

The consumer resource model requires the use of the `randomE` function, which returns a matrix containing the production rates and consumption rates of each species. The resulting matrix is used as a determination of resource consumption efficiency.

```{r}
crmodel <- simulateConsumerResource(n_species = 2,n_resources = 4, E = randomE(n_species = 2, n_resources = 4))

```

## Data containers

The output of simulation functions are `TreeSummarizedExperiment`
object. This provides access to a broad range of
tools for microbiome analysis that support this format (see
[microbiome.github.io](http://microbiome.github.io)). More examples on
`TreeSummarizedExperiment` object manipulation and analysis can be found
at [OMA Online Manual](https://microbiome.github.io/OMA).

```{r}
A_normal <- powerlawA(n_species = 4, alpha = 3)

glvmodel <- simulateGLV(n_species = 4, A = A_normal, t_start = 0, 
    t_store = 1000, stochastic = FALSE, norm = FALSE)
```

The community simulations result in abundance matrix that can be stored in
`TreeSummarizedExperiment` [@TreeSE]  class object. Other fields, such as rowData 
containing information about the samples, and colData, consisting of sample 
metadata describing the samples, can be added to the `TreeSummarizedExperiment` 
class object. 

```{r}
hubbellmodelRates <- simulateHubbellRates(x0 = c(0,5,10),
    migration_p = 0.1, metacommunity_probability = NULL, k_events = 1, 
    growth_rates = NULL, norm = FALSE, t_end=1000)

```

A broad range of functions are available in other packages to explore data in the `TreeSummarizedExperiment` format (see e.g. microbiome.github.io).

For instance, to plot population density we can use the `miaViz` package:

```{r eval=FALSE, include=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("miaViz")

```

```{r}
library(miaViz)

HubbellDensityPlot <- plotAbundanceDensity(hubbellmodel)
HubbellLinePlot <- plotSeries(hubbellmodel, x = "time")
```

### Auxiliary functions

The `simulationTimes` function generates lists of time series that can be specified as simulation time and time points to keep in simulated time.

```{r}
Time <- simulationTimes(t_start = 0, t_end = 100, t_step = 0.5, 
                           t_store = 100)
#  Time$t_sys contains all time points, and Time$t_index stores the selected index for time points to store. Therefore, Time$t_sys[Time$t_index] returns the selected time points. Note that the tail would be trimmed when the interval between start and end cannot be divided exactly by step length with no remainder.
Time$t_sys[Time$t_index]
```

## Generating multiple simulations at once

```{r}
crm_params <- list(
    n_species = 10,
    n_resources = 5,
    E = randomE(
        n_species = 10, n_resources = 5,
        mean_consumption = 1, mean_production = 3
    ),
    x0 = rep(0.001, 10),
    resources = rep(1000, 5),
    monod_constant = matrix(rbeta(10 * 5, 10, 10), nrow = 10, ncol = 5),
    inflow_rate = .5,
    outflow_rate = .5,
    migration_p = 0,
    stochastic = TRUE,
    t_start = 0,
    t_end = 20,
    t_store = 100,
    growth_rates = rep(2, 10),
    norm = FALSE
)

###  restructure the parameter list
param_iter_new <-replicate(8, list(list(x0 = runif(n = 10, min = 0.01, max = 0.02))))

CRMSimus_single_param_new <- list()
CRMSimus_single_param_new <- lapply(
  param_iter_new,
  function(pars){
    do.call(
      what = simulateConsumerResource,
      args = modifyList(crm_params, val = pars)
    )
  }
)
```


```{r}
## 2. demo to iterate combinations of parameters e.g. 9 different x0 and 9 different growth_rates
param_iter2_new <- replicate(9, list(list(x0 = runif(n = 10, min = 0.01, max = 0.02),
                                          growth_rates = runif(n=10, min = 0.5, max = 1))))

CRMSimus_double_param_new <- list()
CRMSimus_double_param_new <- lapply(
  param_iter2_new,
  function(pars){
    do.call(
      what = simulateConsumerResource,
      args = modifyList(crm_params, val = pars)
    )
  }
)
```


```{r}
## 3 demo multiple instances
CRMsimus_multiple_instances_new <- lapply(
  seq_len(5),
  function(pars){
    do.call(
      what = simulateConsumerResource,
      args = crm_params
    )
  }
)
```


```{r}
## 4&5 demo to iterate multiple instances
CRMSimus_single_param_multiple_instances_new <- lapply(
  rep(param_iter_new, each = 3), 
  # or rep(param_iter_new, times = 3), depending on how you'd like to organize the data
  function(pars){
    do.call(
      what = simulateConsumerResource,
      args = modifyList(crm_params, val = pars)
    )
  }
)

CRMSimus_single_param_multiple_instances_new <- lapply(
  rep(param_iter2_new, each = 4),
  function(pars){
    do.call(
      what = simulateConsumerResource,
      args = modifyList(crm_params, val = pars)
    )
  }
)
```

It is also possible to incorporate phylogenetic tree information into
`TreeSummarizedExperiment` objects. For further details, see:

```{r}
library(TreeSummarizedExperiment)
help("TreeSummarizedExperiment-constructor", package = TreeSummarizedExperiment)
```

## Related work

-   [micodymora](https://github.com/OSS-Lab/micodymora) Python package for microbiome simulation

# Session info

```{r}
sessionInfo()
```
